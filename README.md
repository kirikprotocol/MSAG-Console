MSAG - General Description
==========================

MSAG stands for Mobile Service Aggregation Gateway. 
It is a highly intelligent system designed for routing and transitional processing of messages between a service and its users. 
MSAG was initially designed to handle SMS and USSD messages generated by short message entities of mobile networks but later got the ability to support nearly all modern messaging platforms, including Telegram, Facebook, Skype, etc. 
The place of MSAG in the messaging environment is presented in the following figure.

![MSAG In Environment](https://github.com/kirikprotocol/MSAG-Console/blob/master/MSAG_in_Environment.png)


MSAG Functions
==============

Routing
-------

The system uses registration records for every messaging platform MSAG is connected to on the one side and for every service on the other side. 
The Routing Module determines the connection between a service and a user and employs the proper route. One service can uniformly communicate with the same user through different messaging platforms. 
MSAG selects the route in accordance with the messenger the user currently uses to communicate with the service.


Rules
-----

Rules are handled by Rule Engine, the module that keeps a set of pre-defined rules and applies them to the messages that require special care. Those rules are:

*   Charging of messages, if applicable;
*   Insertion of text or multimedia elements into messages, e.g. advertisements;
*   Delaying delivery of messages for a specified time;
*   Cancellation of message delivery (e.g. if the sender or recipient is in the blacklist);
*   Other actions, or a combination of different rules.

In the creation of rules, the Rule Engine uses semantic modeling approach, so that even a person without programming skills can quickly model elaborate service scenarios.

Collection of Statistical Data
------------------------------

A module named StatisticsManager is responsible for registering routing specific events information of which it receives from EventHandler modules. 
The statistical data includes service identifier, user identifier, route identifier, service category, applied rules, etc., which makes convenient sorting and filtering of statistical data. 
Event counters are used for periodical transfer of statistical data to the permanent storage (statistics files).

Traffic Control
---------------

MSAG has several mechanisms by means of which it controls traffic, both overall and by destination. 
MSAG can limit the traffic to a certain number of messages per second, completely stop the traffic to a certain destination, monitor and visualize the system performance.

Construction of Rules Using Semantic Language
=============================================

The semantic language uses the XML syntax.

The rule is a sequence of actions or calls to MSAG's internal objects or subsystems. 
These actions can manage billing transactions, modify passing messages (transport packages), use various session-wide or local variables. 
The rule is called to process an event (a message). It returns the result using a special action `return`.

Variables and Constants
-----------------------

The semantic language support several classes of variables and constants.

|Syntax|Class|
|------|-----|
|`@<constant_name>`|named constant|
|`#<field_name>`|field of a transport event (command)|
|`$<variable_name>`|session-wide variable|
|`%<variable_name>`|local variable|

A field is a an object of types `boolean`, `integer`, `string`, `date`/`time`.

### Constants

Constants can serve as an argument for actions (the same as variables), but they cannot be modified in the process of executing a rule. 
Named constants can be defined in the system. Constants (global and rule-specific) are set in the section where rules are defined. 
A set of default constants is also defined (e.g. error codes). 
The syntax `@<constant_name>` is used to call a named constant, e.g. `@SMPP_ROK`, `@TRUE`, `@FALSE`.

### Command (Transport Event)

The language allows to access and modify fields in the transport packages. 
The syntax `#<field_name>` is used to access a field of a transport event. 
Access to concrete data of a certain packet is made using a command adapter.

### Local Variables

Local variables are created and can be accessed only during the running of a certain handler in a rule. 
A local variable is created and given a value using an action `set`. 
The syntax `%<variable_name>` is used to access a local variable.

### Session-wide Variables

Session-wide variables are created during the running of handlers in rules. 
The lifetime of a session-wide variable is that of a session. 
The syntax `$<variable_name>` is used to access a session-wide variable. 
Specific fields of a session-wide variable are accessed through the session adapter.

Basic Actions
-------------

### Set

Action `Set` creates a variable and initialises it with a value, or redefine an already existing variable.
The syntax:

    <set var=”<variable_name>” value=”<поле>”/>


### Return

Action `Return` interrupts the sequence of actions of a rule and returns the result of the rule execution. 
The syntax:

    <return result=”<поле>” ... />

### Conditional Actions (Forking)

#### if ... then ... else

This action checks a field taking into account additional parameters (op, value) and execute a sequence of enclosed actions (`then`), if the result is positive, or the alternative sequence (`else`), if the result is negative. The syntax:


    <if test=”<field_1>” [op=”<op_1> | <op_2>” value=”<field_2>”]>  
              (<action>)+ |  
              <then>  
                         (<action>)+  
              </then>  
              <else>  
                        (<action>)+  
              </else>  
    </if>


    <op_1> ::= eq | ne | gt | ge | lt | le  
    <op_2> ::= eqi | nei | gti | gei | lti | lei

If `op` and `value` are not specified, `field_1` is checked (it should be the boolean type).

Operations of the second type are used for comparison of integer-valued fields, operations of the first type are used in all other cases.

#### choose

This action verifies a number of conditions (`when test`) and executes a corresponding sequence of actions. 
If neither condition is met, the default sequence of actions is executed (`otherwise`). The syntax:

    <choose>  
              (<when test=”<field_i>” [op=”<op_1> | <op_2>” value=”<field_j>”]>  
                          (<action>)+  
              </when>)+  
              <otherwise>  
                          (<action>)+  
             </otherwise >  
    </choose>
    
    <op_1> ::= eq | ne | gt | ge | lt | le   
    <op_2> ::= eqi | nei | gti | gei | lti | lei

If _op_ and _value_ are not specified, `field_1` is checked (it should be the boolean type).

Operations of the second type are used for comparison of integer-valued fields, operations of the first type are used in all other cases.

### Sessions and Operations

Sessions are used in the process of executing rules in RuleEngine to get access to persistent variables and to support billing transactions. 
The session is passed to an event handler together with the command and then set in the ActionContext. 
When a command is passed to EventHandler, the current operation of the session is created, or determined based on the command being executed.

#### operation:wait

This action is used to instruct to wait for a new operation. 
The action tells the system that it should wait for the start of a new operation of the specified type (`type`) within the current session. 
The waiting time is set by the parameter `time` specified in seconds. The syntax:

    <operation:wait type=”<operation_type>” time=”<field>”/>

#### session:abort

The action `session:abort` is used for abnormal session termination. 
The action destroys the current session with all its variables and operations; the billing transactions (if exist) are rolled back. 
The action is normally accompanied by an error written in the log and the action `return`. The syntax:

    <session:abort/>

### Traffic Control

The action traffic:check is used for traffic control. This function allows the administrator to automatically apply restrictions on a message flow for a specified time period (second/minute/hour/day) on a route for which the rule is set. If such a restriction is triggered, a set of incapsulated actions is executed (which usually ends with the call of `return` action). 
The syntax:

    <traffic:check max=”<field_1>” period=”(sec|min|hour|day)”>  
              (<action>)+  
    </traffic:check>

### Logging

Logging is used to inform the administrator, a service provider, or another involved entity, about errors and unauthorized actions. 
It also helps to monitor and the process of rule execution, fine-tuning or debugging.

The proposed scheme is **log4cpp** with appenders by categories and log levels. The syntax:

    <log level=”(error | warn | info | debug)”  
         category=”<field_1>” message=”<field_2>”/>

When setting categories it is advisable to use rule-specific constants.

### Billing

The way the system interoperate with billing system depends on the billing system type. 
The main key for billing transaction identification (client address + server address) is submitted to the action handler implicitly, in fields of the executed command (sender/recipient). 
Parameters of the additional key can be explicitly set in the XML description of the rule and/or obtained through ActionContext (local and session-wide variables).

The basic mechanism of billing system interworking is as follows. 
A transaction opens using the `open` method, applies using the `commit` method, and rolls back using the `rollback` method. 
Every method returns the execution status or an error code. Upon opening the transaction is registered in the current session operation. 
When the transaction applies/rolls back, it is deregistered. 
Below are the examples of actions specific for billing interworking.

#### bill:open

This action opens a billing transaction. 
For pre-paid billing scenarios a requested sum is reserved on the subscriber's account, for post-paid billing scenarios `Ok` is immediately returned. 
In both cases, a transaction is initiated in the billing machine and the current operation creates an access key. 
If the attempt fails, or some error occurs in the process, an error code is returned in the `status` field and the corresponding message in the `msg` field. 
The subsequent `if` or `choose` action handles the error. 
The `service` field (optionally) simulates the service address using the additional transaction key. The syntax:

    <sibinco:bill:open [service=”<field_1>”]  
                       [status=”<field_2>”][msg=”<field_3>”]/>

#### bill:commit

This action applies the opened transaction in the current operation. 
In the post-paid scenario a billing record is created, in the pre-paid scenario the reserved sum is debited from the subscriber's account. 
The transaction is closed and deregistered in the current operation. If the attempt fails, or some error occurs in the process, an error code is returned in the `status` field and the corresponding message in the `msg` field. 
The `service` parameter (optionally) defines the additional transaction key. The syntax:

    <sibinco:bill:commit [service=”<field_1>”]  
                         [status=”<field_2>”][msg=”<field_3>”]/>

#### bill:rollback

This action cancels the previous transaction. In the post-paid scenario nothing happens (the record is not created), in the pre-paid scenario the transaction is canceled and the reserved sum is unblocked. 
The transaction is closed and deregistered in the current operation. 
If the attempt fails, or some error occurs in the process, an error code is returned in the `status` field and the corresponding message in the `msg` field. 
The `service` parameter (optionally) defines the additional transaction key. The syntax:

    <sibinco:bill:rollback [service=”<field_1>”]  
                           [status=”<field_2>”] [msg=”<field_3>”]/>

Add-on Actions
--------------

Apart from the basic actions with sessions, billing systems, and statistics the system user can require additional actions connected with parsing, formatting, and modifying variable values. 
These actions are made in the same manner as the basic actions, use the same language structure, and are semantically equal to the basic actions.

System Configuration
====================

This section considers methods of how the system and its subsystems can be configured by means of the administration interface. 
It also describes parameter sets that the administrator can modify while the system is in operation and the parameters that can only be initialized after full system restart. 
The description of parameters is split by groups and subsystems.

Menu System
-----------

The menu system gives access to configuration parameter groups, statistical data, subsystem configuration controls, route sets, rules, etc. 
The table below lists the menu items and their submenus.

<table>
<tbody>
<tr>
<th>Menu</th>
<th>Submenu</th>
<th>Brief description</th></tr>
<tr>
<td rowspan="5">MSAG</td>
<td>Status</td>
<td>System start/stop and configuration change log.</td></tr>
<tr>
<td>Configuration</td>
<td>Global system settings (ports, directories, etc.). Changes become effective only after full system restart.</td></tr>
<tr>
<td>Providers</td>
<td>Addition, removal, modification of service provider accounts. A provider is assigned a list of categories. Providers and their categories determine ownership of routes and services. Changes become effective immediately with a related record added to the log.</td></tr>
<tr>
<td>Logging</td>
<td>The page where service provider related logging is controlled (appenders and the category tree with log levels). The basic log categories for a provider are those defined at page <em>Providers</em>. <span>Changes become effective immediately, no record is made in the log.</span></td></tr>
<tr>
<td>Users</td>
<td><span>Addition, removal, modification of accounts for users of the administration interface (administrators and providers), role management. <span>Changes become effective immediately, no record is made in the log.</span></span></td></tr>
<tr>
<td rowspan="4">Endpoints</td>
<td>Services</td>
<td>Addition, removal, modification of accounts and individual settings for services (dropdown list or filter: SMPP, WAP, or MMS). Restrictions on providers (only own services). <span>Changes become effective immediately with a related record added to the log.</span></td></tr>
<tr>
<td>Services monitor</td>
<td>Service operation monitoring (tabs: SMPP, WAP, and MMS). <span>Restrictions on providers (only own services).</span></td></tr>
<tr>
<td>Centers</td>
<td><span>Addition, removal, modification of accounts and individual settings for centers (dropdown list or filter: SMS Centre, WAP Gateway, MMS Gateway). Unaccessible by service providers. <span>Changes become effective immediately with a related record added to the log.</span></span></td></tr>
<tr>
<td>Centers monitor</td>
<td>Operation monitoring of SMS Centres and WAP/MMS Gateways (tabs: SMPP, WAP, and MMS. <span>Unaccessible by service providers.</span></td></tr>
<tr>
<td rowspan="3">Routing</td>
<td>Subjects</td>
<td>Addition, removal, modification of subjects. Applicable together with routes on the <em>Routes</em> page.</td></tr>
<tr>
<td>Routes</td>
<td><span>Addition, removal, modification of routes. Applying, saving, rollback of route configuration. <span>Changes become effective immediately with a related record added to the log.</span></span></td></tr>
<tr>
<td>Routes tracing</td>
<td>Route checking. Control is made on the <em>Routes</em> page.</td></tr>
<tr>
<td rowspan="2">Rules</td>
<td>Rules</td>
<td><span>Addition, removal, modification of rules. Preliminary checking (compilation), applet-based XML editor. <span>Changes become effective immediately with a related record added to the log.</span></span></td></tr>
<tr>
<td>Rule wizard</td>
<td>A wizard for rule creation. Templates are available. When rule creation is complete, transition is made to the list of rules.</td></tr>
<tr>
<td rowspan="2">Statistics</td>
<td>Performance monitor</td>
<td>General system performance monitor (tabs: SMPP, WAP, MMS).</td></tr>
<tr>
<td>Statistics data</td>
<td>Selection of statistical data for a specified period. The administrator has access to all statistical data, service providers can access only their related route statistics. Filtering by transport types and categories is available.</td></tr></tbody>
</table>


MSAG Interworking - General Practice
------------------------------------

Changes are applied by a command from the administration interface. 
Changes are registered in XML configuration files of related subsystems, reserve copies of the changed files are made. 
A command for change is sent to the Gateway with an indication of the changes that should be applied; the Gateway reloads the required parameters.

Should an error occur in the process of applying changes for a subsystem, the administrator receives a corresponding message and rollback to the previous configuration version is made for that subsystem.