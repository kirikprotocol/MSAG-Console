/* ************************************************************************* *
 * TCAP Abort Message Encoder.
 * ************************************************************************* */
#ifndef __EYELINE_TCAP_PROTO_TABORT_HPP
#ifndef __GNUC__
#ident "@(#)$Id$"
#endif
#define __EYELINE_TCAP_PROTO_TABORT_HPP

#include "eyeline/tcap/proto/enc/TEPAbortCause.hpp"
#include "eyeline/tcap/proto/enc/TETransactionId.hpp"
#include "eyeline/tcap/proto/enc/TEDialoguePortion.hpp"

namespace eyeline {
namespace tcap {
namespace proto {
namespace enc {

/* Abort is defined in IMPLICIT tagging environment as follow:
Abort ::= [APPLICATION 7] SEQUENCE {
  dtid    DestTransactionID,
  reason  CHOICE {
	      p-abortCause  P-AbortCause,
	      u-abortCause  DialoguePortion
	  } OPTIONAL
}
-- NOTE - When the Abort Message is generated by the Transaction sublayer,
-- a p-Abort Cause may be present. The u-abortCause may be generated by the
-- component sublayer in which case it is an ABRT APDU, or by the TC-User in
-- which case it could be either an ABRT APDU or data in some user-defined
-- abstract syntax or AARE APDU as a response to received TBegin.
*/
class TETAbort : public asn1::ber::EncoderOfStructure_T<2> {
protected:
  class CauseEncoder : public asn1::ber::ChoiceOfEncoders2_T<
                              TEPAbortCause, TEDialoguePortionStructured> {
  public:
    Alternative_T<TEPAbortCause>        pAbort()  { return alternative0(); }
    ConstAlternative_T<TEPAbortCause>   pAbort()  const { return alternative0(); }

    //NOTE: only ABRT_APdu, AARE_APdu or ASExternal is allowed
    Alternative_T<TEDialoguePortionStructured>      uAbort()  { return alternative1(); }
    ConstAlternative_T<TEDialoguePortionStructured> uAbort()  const { return alternative1(); }
  };

/* ----------------------------------------------- */
  TEDestTransactionId   _trIdDst;
  CauseEncoder          _cause;

/* ----------------------------------------------- */
  TEDialoguePortionStructured * initDlgPortion(void);

public:
  static const asn1::ASTagging _typeTags;

  explicit TETAbort(uint32_t remote_tr_id,
                    asn1::TransferSyntax::Rule_e use_rule = asn1::TransferSyntax::ruleDER)
    : asn1::ber::EncoderOfStructure_T<2>(_typeTags, use_rule)
    , _trIdDst(remote_tr_id, use_rule)
  {
    asn1::ber::EncoderOfStructure_T<2>::setField(0, _trIdDst);
  }
  ~TETAbort()
  { }

  TEPAbortCause * setPrvdAbort(PAbort::Cause_e use_cause = PAbort::p_resourceLimitation);

  //Indicates that TCUser aborts already established dialog with some
  //externally defined DataValue provided as reason.
  void setUserAbort(const asn1::ASExternal & use_ext)
  {
    initDlgPortion()->setValue(use_ext);
  }

  //Indicates that TCUser aborts already established dialog with optional
  //UserInfo provided as reason. Creates and initializes ABRT_APdu
  //Returns ABRT_APdu for addition of optional UsrInfo
  TEAPduABRT * setUserAbort(void)
  {
    return initDlgPortion()->initPduABRT(TDialogueAssociate::abrtServiceUser);
  }

  //Indicates that TCUser aborts establishing a dialog (response to TBegin).
  //Creates and initializes AARE_APdu
  //Returns AARE_APdu for addition of optional UsrInfo
  TEAPduAARE * setUserReject(const asn1::EncodedOID & app_ctx,
                             AssociateSourceDiagnostic::DiagnosticUser_e use_cause
                             = AssociateSourceDiagnostic::dsu_null)
  {
    TEAPduAARE * pdu = initDlgPortion()->initPduAARE(app_ctx);
    pdu->rejectByUser(use_cause);
    return pdu;
  }
};

}}}}

#endif/* __EYELINE_TCAP_PROTO_TABORT_HPP */

