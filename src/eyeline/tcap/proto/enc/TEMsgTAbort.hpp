/* ************************************************************************* *
 * TCAP Abort Message Encoder.
 * ************************************************************************* */
#ifndef __EYELINE_TCAP_PROTO_TABORT_HPP
#ident "@(#)$Id$"
#define __EYELINE_TCAP_PROTO_TABORT_HPP

#include "eyeline/tcap/proto/enc/TEPAbortCause.hpp"
#include "eyeline/tcap/proto/enc/TETransactionId.hpp"
#include "eyeline/tcap/proto/enc/TEDialoguePortion.hpp"

namespace eyeline {
namespace tcap {
namespace proto {
namespace enc {

/* Abort is defined in IMPLICIT tagging environment as follow:
Abort ::= [APPLICATION 7] SEQUENCE {
  dtid    DestTransactionID,
  reason  CHOICE {
	      p-abortCause  P-AbortCause,
	      u-abortCause  DialoguePortion
	  } OPTIONAL
}
-- NOTE - When the Abort Message is generated by the Transaction sublayer,
-- a p-Abort Cause may be present. The u-abortCause may be generated by the
-- component sublayer in which case it is an ABRT APDU, or by the TC-User in
-- which case it could be either an ABRT APDU or data in some user-defined
-- abstract syntax or AARE APDU as a response to received TBegin.
*/
class TETAbort : public asn1::ber::EncoderOfPlainStructure_T<2> {
private:
  using asn1::ber::EncoderOfPlainStructure_T<2>::addField;
  using asn1::ber::EncoderOfPlainStructure_T<2>::setField;

  union {
    void * aligner;
    uint64_t buf[eyeline::util::MultiplierOfSize_T<
                    eyeline::util::MaxSizeOf2_T<
                        TEPAbortCause, TEDialoguePortionStructured>::VALUE
                    , uint64_t>::VALUE];
  } _memCause;

protected:
  TEDestTransactionId           _trIdDst;
  TEPAbortCause *               _causePrvd;
  TEDialoguePortionStructured * _causeUser; //NOTE: only ABRT_APdu, AARE_APdu or ASExternal is allowed

  TEDialoguePortionStructured * getDlgPortion(void)
  {
    if (!_causeUser) {
      _causeUser = new (_memCause.buf)TEDialoguePortionStructured(TSGroupBER::getBERRule(getTSRule()));
      asn1::ber::EncoderOfPlainStructure_T<2>::setField(1, *_causeUser);
    }
    return _causeUser;
  }

public:
  static const asn1::ASTagging _typeTags;

  explicit TETAbort(uint32_t remote_tr_id, TSGroupBER::Rule_e use_rule = TSGroupBER::ruleDER)
    : asn1::ber::EncoderOfPlainStructure_T<2>(_typeTags, TSGroupBER::getTSRule(use_rule))
    , _trIdDst(remote_tr_id, use_rule), _causePrvd(0), _causeUser(0)
  {
    _memCause.aligner = 0;
    asn1::ber::EncoderOfPlainStructure_T<2>::addField(_trIdDst);
  }
  ~TETAbort()
  {
    if (_causePrvd)
      _causePrvd->~TEPAbortCause();
    else if (_causeUser)
      _causeUser->~TEDialoguePortionStructured();
  }

  TEPAbortCause * setPrvdAbort(PAbort::Cause_e use_cause = PAbort::p_resourceLimitation)
  {
    _causePrvd = new (_memCause.buf)TEPAbortCause(use_cause, TSGroupBER::getBERRule(getTSRule()));
    asn1::ber::EncoderOfPlainStructure_T<2>::setField(1, *_causePrvd);
    return _causePrvd;
  }

  //Indicates that TCUser aborts already established dialog with some
  //externally defined DataValue provided as reason.
  void setUserAbort(const asn1::ASExternal & use_ext)
  {
    getDlgPortion()->setValue(use_ext);
  }

  //Indicates that TCUser aborts already established dialog with optional
  //UserInfo provided as reason. Creates and initializes ABRT_APdu
  //Returns ABRT_APdu for addition of optional UsrInfo
  TEAPduABRT * setUserAbort(void)
  {
    return getDlgPortion()->getPduABRT(TDialogueAssociate::abrtServiceUser);
  }

  //Indicates that TCUser aborts establishing a dialog (response to TBegin).
  //Creates and initializes AARE_APdu
  //Returns AARE_APdu for addition of optional UsrInfo
  TEAPduAARE * setUserReject(const asn1::EncodedOID & app_ctx,
                             AssociateSourceDiagnostic::DiagnosticUser_e use_cause
                             = AssociateSourceDiagnostic::dsu_null)
  {
    TEAPduAARE * pdu = getDlgPortion()->getPduAARE(app_ctx);
    pdu->rejectByUser(use_cause);
    return pdu;
  }
};

}}}}

#endif/* __EYELINE_TCAP_PROTO_TABORT_HPP */

