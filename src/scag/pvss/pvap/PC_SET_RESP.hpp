// NOTE: Do NOT edit this file (it is auto-generated).
// Instead, edit message-cpp.tmpl and regenerate.

#ifndef __SCAG_PVSS_PVAP_PC_SET_RESP_HPP__
#define __SCAG_PVSS_PVAP_PC_SET_RESP_HPP__

#include "util/int.h"
#include <string>
#include "Exceptions.h"


namespace scag{
namespace pvss{
namespace pvap{

class PC_SET_RESP  
{
public:
    PC_SET_RESP()
    {
        clear();
    }
    void clear()
    {
        statusFlag=false;
    }

    std::string toString() const
    {
        std::string rv("PC_SET_RESP:");
        char buf[32];
        sprintf(buf,"seqNum=%d",seqNum);
        rv+=buf;
        if(statusFlag) {
            rv+=";status=";
            sprintf(buf,"%u",(unsigned int)status);
            rv+=buf;
        }
        return rv;
    }

    template <class DataStream> uint32_t length()const
    {
        uint32_t rv=0;
        if (statusFlag) {
            rv+=DataStream::tagTypeSize;
            rv+=DataStream::lengthTypeSize;
            rv+=DataStream::fieldSize(status);
        }
        return rv;
    }

  uint8_t getStatus() const
    {
        if (!statusFlag) {
            throw FieldIsNullException("status");
        }
        return status;
    }

    void setStatus(uint8_t value)
    {
        status=value;
        statusFlag=true;
    }
    bool hasStatus()const
    {
        return statusFlag;
    }

    template <class DataStream> void serialize(DataStream& ds) const
    {
        checkFields();
        // mandatory fields
        ds.writeTag(statusTag);
    ds.writeByteLV(status);
        // optional fields
        //ds.writeTag(DataStream::endOfMessage_tag);
    }

    template <class DataStream> void deserialize(DataStream& ds)
    {
        clear();
        bool endOfMessage=false;
        //uint8_t rdVersionMajor=ds.readByte();
        //uint8_t rdVersionMinor=ds.readByte();
        //if(rdVersionMajor!=versionMajor)
        //{
        //  throw IncompatibleVersionException("PC_SET_RESP");
        //}
        //seqNum=ds.readInt32();
        while (!endOfMessage) {
            uint32_t tag=ds.readTag();
            switch(tag) {
            case statusTag: {
                if (statusFlag) {
                    throw DuplicateFieldException("status");
                }
          status=ds.readByteLV();
                statusFlag=true;
                break;
            }
            case DataStream::endOfMessage_tag:
                endOfMessage=true;
                break;
            default:
                //if(rdVersionMinor==versionMinor)
                //{
                //  throw UnexpectedTag("PC_SET_RESP",tag);
                //}
                ds.skip(ds.readLength());
            }
        }
        checkFields();
    }

    uint32_t getSeqNum() const
    {
        return seqNum;
    }
 
    void setSeqNum(uint32_t value)
    {
        seqNum=value;
    }

protected:
    void checkFields() const throw (MandatoryFieldMissingException)
    {
        // checking mandatory fields
        if (!statusFlag) {
            throw MandatoryFieldMissingException("status");
        }
        // checking optional fields
    }

protected:
    //static const uint8_t versionMajor=2;
    //static const uint8_t versionMinor=0;

    static const uint16_t statusTag=1;

    uint32_t seqNum;

    uint8_t status;

    bool statusFlag;
};

} // namespace scag
} // namespace pvss
} // namespace pvap
#endif
