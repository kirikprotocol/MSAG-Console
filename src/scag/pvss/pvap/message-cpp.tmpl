// NOTE: Do NOT edit this file (it is auto-generated).
// Instead, edit message-cpp.tmpl and regenerate.

#ifndef __SCAG_PVSS_PVAP_$var message.name:uc$_HPP__
#define __SCAG_PVSS_PVAP_$var message.name:uc$_HPP__

#include "util/int.h"
#include <string>
#include "scag/pvss/pvap/Exceptions.h"
#include "scag/pvss/pvap/TypeId.h"
$foreach field$
$select field.type$
$case byte$
$case uint16$
$case uint32$
$case uint64$
$case string$
$case ascii$
$case utf8$
$case bool$
$case nested$#include "$var field.typename$.hpp"
$default$#include "scag/pvss/pvap/$var field.type$.h"
$-select$
$-foreach$
$if options.inheritsFromBatchCmd$#include "scag/pvss/pvap/BatchCmd.h"$-if$

$macro type$$pack$
$select %1$
 $case byte$uint8_t
 $case uint16$uint16_t
 $case uint32$uint32_t
 $case uint64$uint64_r
 $case string$const std::string&
 $case ascii$const std::string&
 $case utf8$const std::string&
 $case bool$bool
 $case nested$const $var field.typename$&
 $default$const $var field.type$&
$-select$$-pack$$-macro$

$foreach namespace$
namespace $var namespace${
$-foreach$

// class $var protocol.name:ucf$;

class $var message.name$ $if options.inheritsFromBatchCmd$: public BatchCmd$-if$ 
{
public:
$if options.inheritsFromBatchCmd$
    inline int getId() const throw () { return TypeId<$var message.name$>::getId(); }

$-if$
    $var message.name$()
    {
        clear();
    }

    bool isRequest() const {
        return $if message.request$true$-if$$if !message.request$false$-if$;
    }

    void clear()
    {
$foreach field$
        $var field.name$Flag=false;
$-foreach$
    }

    std::string toString() const
    {
        std::string rv("$var message.name$:");
        char buf[32];
        sprintf(buf,"seqNum=%d",seqNum);
        rv+=buf;
$foreach field$
        if($var field.name$Flag) {
            rv+=";$var field.name$=";
$select field.type$
$case byte$
            sprintf(buf,"%u",(unsigned int)$var field.name$);
            rv+=buf;
$case uint16$
            sprintf(buf,"%u",(unsigned int)$var field.name$);
            rv+=buf;
$case uint32$
            sprintf(buf,"%u",(unsigned int)$var field.name$);
            rv+=buf;
$case uint64$
            sprintf(buf,"%llu",$var field.name$);
            rv+=buf;
$case string$
            rv+=$var field.name$;
$case ascii$
            rv+=$var field.name$;
$case utf8$
            rv+=$var field.name$;
$case bool$
            rv+=$var field.name$?"true":"false";
$case nested$
            rv+='(';
            rv+=$var field.name$.toString();
            rv+=')';
$default$
            rv+=$var field.name$.toString();
$-select$
        }
$-foreach$
        return rv;
    }

    /*
    template <class DataStream> uint32_t length()const
    {
        uint32_t rv=0;
$foreach field$
        if ($var field.name$Flag) {
            rv+=DataStream::tagTypeSize;
            rv+=DataStream::lengthTypeSize;
            rv+=DataStream::fieldSize($var field.name$);
        }
$-foreach$
        return rv;
    }
     */

$foreach field$
    $expand type field.type$ get$var field.name:ucf$() const
$if options.throwOnUnsetGet$
        throw (FieldIsNullException)
$-if$
    {
$if options.throwOnUnsetGet$
        if (!$var field.name$Flag) {
            throw FieldIsNullException("$var field.name$");
        }
$-if$
        return $var field.name$;
    }
    void set$var field.name:ucf$($expand type field.type$ value)
    {
        $var field.name$=value;
        $var field.name$Flag=true;
    }
    bool has$var field.name:ucf$()const
    {
        return $var field.name$Flag;
    }
$-foreach$

    template <class Proto, class DataStream> 
        void serialize( const Proto& proto, DataStream& ds ) const throw (PvapException)
    {
        checkFields();
        // mandatory fields
$foreach field$
$if field.mandatory$
        printf( "write pos=%d field=%d\n", ds.getPos(), $var field.name$Tag );
        ds.writeTag($var field.name$Tag);
        $select field.type$
$case string$ds.writeStrLV($var field.name$);
$case ascii$ds.writeByteStringLV($var field.name$);
$case utf8$ds.writeByteStringLV($var field.name$);
$case byte$ds.writeByteLV($var field.name$);
$case uint16$ds.writeInt16LV($var field.name$);
$case uint32$ds.writeInt32LV($var field.name$);
$case uint64$ds.writeInt64LV($var field.name$);
$case bool$ds.writeBoolLV($var field.name$);
$case nested$throw NotImplementedException("$var field.name$");
$default$$var field.name$.serialize(proto,ds);
$-select$
$-if$
$-foreach$
        // optional fields
$foreach field$
$if field.optional$
        if ($var field.name$Flag) {
            printf( "write pos=%d field=%d\n", ds.getPos(), $var field.name$Tag );
            ds.writeTag($var field.name$Tag);
            $select field.type$
$case byte$ds.writeByteLV($var field.name$);
$case uint16$ds.writeInt16LV($var field.name$);
$case uint32$ds.writeInt32LV($var field.name$);
$case uint64$ds.writeInt64LV($var field.name$);
$case string$ds.writeStrLV($var field.name$);
$case ascii$ds.writeByteStringLV($var field.name$);
$case utf8$ds.writeByteStringLV($var field.name$);
$case bool$ds.writeBoolLV($var field.name$);
$case nested$throw NotImplementedException("$var field.name$");
$default$$var field.name$.serialize(proto,ds);
$-select$
        }
$-if$
$-foreach$
    }

    template <class Proto, class DataStream> void deserialize(const Proto& proto, DataStream& ds)
        throw (PvapException)
    {
        clear();
        while (true) {
            int pos = int(ds.getPos());
            int tag = ds.readTag();
            printf( "read pos=%d field=%d\n", pos, tag );
            if ( tag == -1 ) break;
            switch(tag) {
$foreach field$
            case $var field.name$Tag: {
                if ($var field.name$Flag) {
                    throw DuplicateFieldException("$var field.name$");
                }
                $select field.type$
$case byte$$var field.name$=ds.readByteLV();
$case uint16$$var field.name$=ds.readInt16LV();
$case uint32$$var field.name$=ds.readInt32LV();
$case uint64$$var field.name$=ds.readInt64LV();
$case string$$var field.name$=ds.readStrLV();
$case ascii$$var field.name$=ds.readByteStringLV();
$case utf8$$var field.name$=ds.readByteStringLV();
$case bool$$var field.name$=ds.readBoolLV();
$case nested$throw NotImplementedException("$var field.name$");
$default$$var field.name$.deserialize(proto,ds);
$-select$
                $var field.name$Flag=true;
                break;
            }
$-foreach$
            default:
                throw NotImplementedException("reaction of reading unknown");
            }
        }
        checkFields();
    }

    uint32_t getSeqNum() const
    {
        return seqNum;
    }
  
    void setSeqNum(uint32_t value)
    {
        seqNum=value;
    }

protected:
    void checkFields() const throw (MandatoryFieldMissingException)
    {
        // checking mandatory fields
$foreach field$
$if field.mandatory$
        if (!$var field.name$Flag) {
            char buf[256];
            snprintf( buf, sizeof(buf), "field=%s msg=%s", "$var field.name$", "$var message.name$");
            throw MandatoryFieldMissingException(buf);
        }
$-if$
$-foreach$
        // checking optional fields
$foreach field$
$if field.optional$
$ifdef field.checkVar$
        if (!$var field.name$Flag
$ifdef field.checkEq$
            && ($var field.checkVar$==$var field.checkEq$)
$-ifdef$
$ifdef field.checkGt$
            && ($var field.checkVar$>$var field.checkGt$)
$-ifdef$
$ifdef field.checkLt$
            && ($var field.checkVar$<$var field.checkLt$)
$-ifdef$
            ) {
            char buf[256];
            snprintf( buf, sizeof(buf), "field=%s msg=%s", "$var field.name$", "$var message.name$");
            throw MandatoryFieldMissingException(buf);
        }
$-ifdef$
$-if$
$-foreach$
    }

protected:
    //static const uint8_t versionMajor=$var message.versionMajor$;
    //static const uint8_t versionMinor=$var message.versionMinor$;

$foreach field$
    static const int $var field.name$Tag=$var field.tag$;
$-foreach$

    uint32_t seqNum;

$foreach field$
$ifdef field.comment$    //$var field.comment$
$-ifdef$    $pack$
  $select field.type$
  $case byte$uint8_t
  $case uint16$uint16_t
  $case uint32$uint32_t
  $case uint64$uint64_t
  $case string$std::string
  $case ascii$std::string
  $case utf8$std::string
  $case bool$bool
  $case nested$$var field.typename$
  $default$$var field.type$
  $-select$
  $var field.name$$-pack$;
$-foreach$

$foreach field$
    bool $var field.name$Flag;
$-foreach$
};

$foreach namespace$
} // namespace $var namespace$
$-foreach$
#endif
