// NOTE: Do NOT edit this file (it is auto-generated).
// Instead, edit message-cpp.tmpl and regenerate.

#ifndef __SCAG_PVSS_PVAP_$var message.name:uc$_HPP__
#define __SCAG_PVSS_PVAP_$var message.name:uc$_HPP__

#include "util/int.h"
#include <string>
#include "Exceptions.h"
$foreach field$
$select field.type$
$case byte$
$case uint16$
$case uint32$
$case uint64$
$case string$
$case bool$
$case nested$#include "$var field.typename$.hpp"
$default$#include "$var field.type$.h"
$-select$
$-foreach$

$macro type$$pack$
  $select %1$
  $case byte$uint8_t
  $case uint16$uint16_t
  $case uint32$uint32_t
  $case uint64$uint64_r
  $case string$const std::string&
  $case bool$bool
  $case nested$const $var field.typename$&
  $default$const $var field.type$&
  $-select$
$-pack$$-macro$

$foreach namespace$
namespace $var namespace${
$-foreach$

class $var message.name$ $if options.inheritsFromBatchCmd$: public BC_CMD$-if$ {
public:
  $var message.name$()
  {
    Clear();
  }
  void Clear()
  {
$foreach field$
    $var field.name$Flag=false;
$-foreach$
  }

  std::string toString()const
  {
    std::string rv;
    char buf[32];
		sprintf(buf,"seqNum=%d",seqNum);
		rv+=buf;
$foreach field$
    if($var field.name$Flag)
    {
      rv+=";$var field.name$=";
$select field.type$
$case byte$
      sprintf(buf,"%u",(unsigned int)$var field.name$);
      rv+=buf;
$case uint16$
      sprintf(buf,"%u",(unsigned int)$var field.name$);
      rv+=buf;
$case uint32$
      sprintf(buf,"%u",(unsigned int)$var field.name$);
      rv+=buf;
$case uint64$
      sprintf(buf,"%llu",$var field.name$);
      rv+=buf;
$case string$
      rv+=$var field.name$;
$case bool$
      rv+=$var field.name$?"true":"false";
$case nested$
      rv+='(';
      rv+=$var field.name$.toString();
      rv+=')';
$default$
      rv+=$var field.name$.toString();
$-select$
    }
$-foreach$
    return rv;
  }

  template <class DataStream>
  uint32_t length()const
  {
    uint32_t rv=0;
$foreach field$
    if($var field.name$Flag)
    {
      rv+=DataStream::tagTypeSize;
      rv+=DataStream::lengthTypeSize;
      rv+=DataStream::fieldSize($var field.name$);
    }
$-foreach$

    return rv;
  }
$foreach field$
  $expand type field.type$ get$var field.name:ucf$()const
  {
$if options.throwOnUnsetGet$
    if(!$var field.name$Flag)
    {
      throw FieldIsNullException("$var field.name$");
    }
$-if$
    return $var field.name$;
  }
  void set$var field.name:ucf$($expand type field.type$ value)
  {
    $var field.name$=value;
    $var field.name$Flag=true;
  }
  bool has$var field.name:ucf$()const
  {
    return $var field.name$Flag;
  }
$-foreach$

  template <class DataStream>
  void serialize(DataStream& ds)const
  {
$foreach field$
$if field.mandatory$
    if(!$var field.name$Flag)
    {
      throw MandatoryFieldMissingException("$var field.name$");
    }
$-if$
$-foreach$
    // checking profile type
$foreach field$
$ifdef field.checkVar$
    if (!$var field.name$Flag &&
$ifdef field.checkEq$
       ($var field.checkVar$==$var field.checkEq$) &&
$-ifdef$
$ifdef field.checkGt$
       ($var field.checkVar$>$var field.checkGt$) &&
$-ifdef$
$ifdef field.checkLt$
       ($var field.checkVar$<$var field.checkLt$) &&
$-ifdef$
       true )
    {
      throw MandatoryFieldMissingException("$var field.name$");
    }
$-ifdef$
$-foreach$
    //ds.writeByte(versionMajor);
    //ds.writeByte(versionMinor);
    //ds.writeInt32(seqNum);
$foreach field$
$if field.mandatory$
    ds.writeTag($var field.name$Tag);
    $select field.type$
$case byte$ds.writeByteLV($var field.name$);
$case uint16$ds.writeInt16LV($var field.name$);
$case uint32$ds.writeInt32LV($var field.name$);
$case uint64$ds.writeInt64LV($var field.name$);
$case string$ds.writeStrLV($var field.name$);
$case bool$ds.writeBoolLV($var field.name$);
$case nested$ds.writeLength($var field.name$.length<DataStream>());
    $var field.name$.serialize(ds);
$default$
$ifdef field.serialize$
    ds.get$var field.serializer$().serialize(ds,$var field.name$);
$-ifdef$
$-select$
$-if$
$-foreach$
$foreach field$
$if field.optional$
    if($var field.name$Flag)
    {
      ds.writeTag($var field.name$Tag);
      $select field.type$
$case byte$ds.writeByteLV($var field.name$);
$case uint16$ds.writeInt16LV($var field.name$);
$case uint32$ds.writeInt32LV($var field.name$);
$case uint64$ds.writeInt64LV($var field.name$);
$case string$ds.writeStrLV($var field.name$);
$case bool$ds.writeBoolLV($var field.name$);
$case nested$ds.writeLength($var field.name$.length<DataStream>());
      $var field.name$.serialize(ds);
$default$
$ifdef field.serialize$
    ds.get$var field.serializer$().serialize(ds,$var field.name$);
$-ifdef$
$-select$
    }
$-if$
$-foreach$
    //ds.writeTag(DataStream::endOfMessage_tag);
  }

  template <class DataStream>
  void deserialize(DataStream& ds)
  {
    Clear();
    bool endOfMessage=false;
    //uint8_t rdVersionMajor=ds.readByte();
    //uint8_t rdVersionMinor=ds.readByte();
    //if(rdVersionMajor!=versionMajor)
    //{
    //  throw IncompatibleVersionException("$var message.name$");
    //}
    //seqNum=ds.readInt32();
    while(!endOfMessage)
    {
      uint32_t tag=ds.readTag();
      switch(tag)
      {
$foreach field$
        case $var field.name$Tag:
        {
          if($var field.name$Flag)
          {
            throw DuplicateFieldException("$var field.name$");
          }
          $select field.type$
$case byte$$var field.name$=ds.readByteLV();
$case uint16$$var field.name$=ds.readInt16LV();
$case uint32$$var field.name$=ds.readInt32LV();
$case uint64$$var field.name$=ds.readInt64LV();
$case string$$var field.name$=ds.readStrLV();
$case bool$$var field.name$=ds.readBoolLV();
$case nested$ds.readLength();
          $var field.name$.deserialize(ds);
$default$
$ifdef field.serializer$
       ds.get$var field.serializer$().deserialize(ds,$var field.name$);
$-ifdef$
$-select$
          $var field.name$Flag=true;
        }break;
$-foreach$
        case DataStream::endOfMessage_tag:
          endOfMessage=true;
          break;
        default:
          //if(rdVersionMinor==versionMinor)
          //{
          //  throw UnexpectedTag("$var message.name$",tag);
          //}
          ds.skip(ds.readLength());
      }
    }
$foreach field$
$if field.mandatory$
    if(!$var field.name$Flag)
    {
      throw MandatoryFieldMissingException("$var field.name$");
    }
$-if$
$-foreach$
    // checking profile type
$foreach field$
$ifdef field.checkVar$
    if (!$var field.name$Flag &&
$ifdef field.checkEq$
       ($var field.checkVar$==$var field.checkEq$) &&
$-ifdef$
$ifdef field.checkGt$
       ($var field.checkVar$>$var field.checkGt$) &&
$-ifdef$
$ifdef field.checkLt$
       ($var field.checkVar$<$var field.checkLt$) &&
$-ifdef$
       true )
    {
      throw MandatoryFieldMissingException("$var field.name$");
    }
$-ifdef$
$-foreach$
  }

  uint32_t getSeqNum()const
  {
    return seqNum;
  }
  
  void setSeqNum(uint32_t value)
  {
    seqNum=value;
  }

protected:
  //static const uint8_t versionMajor=$var message.versionMajor$;
  //static const uint8_t versionMinor=$var message.versionMinor$;

$foreach field$
  static const uint32_t $var field.name$Tag=$var field.tag$;
$-foreach$

  uint32_t seqNum;

$foreach field$
$ifdef field.comment$  //$var field.comment$
$-ifdef$  $pack$
  $select field.type$
  $case byte$uint8_t
  $case uint16$uint16_t
  $case uint32$uint32_t
  $case uint64$uint64_t
  $case string$std::string
  $case bool$bool
  $case nested$$var field.typename$
  $default$$var field.type$
  $-select$
  $var field.name$$-pack$;
$-foreach$

$foreach field$
  bool $var field.name$Flag;
$-foreach$
};

$foreach namespace$
}
$-foreach$
#endif
