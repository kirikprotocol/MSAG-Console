// NOTE: Do NOT edit this file (it is auto-generated).
// Instead, edit message-cpp.tmpl and regenerate.

#ifndef __SCAG_PVSS_PVAP_BC_GET_RESP_HPP__
#define __SCAG_PVSS_PVAP_BC_GET_RESP_HPP__

#include "util/int.h"
#include <string>
#include "Exceptions.h"
#include "TypeId.h"
#include "BC_CMD.h"

namespace scag{
namespace pvss{
namespace pvap{

// class PVAPBC;

class BC_GET_RESP : public BC_CMD 
{
public:
    inline int getId() const throw () { return TypeId<BC_GET_RESP>::getId(); }

    BC_GET_RESP()
    {
        clear();
    }
    void clear()
    {
        statusFlag=false;
        valueTypeFlag=false;
        timePolicyFlag=false;
        finalDateFlag=false;
        lifeTimeFlag=false;
        varNameFlag=false;
        intValueFlag=false;
        stringValueFlag=false;
        boolValueFlag=false;
        dateValueFlag=false;
    }

    std::string toString() const
    {
        std::string rv("BC_GET_RESP:");
        char buf[32];
        sprintf(buf,"seqNum=%d",seqNum);
        rv+=buf;
        if(statusFlag) {
            rv+=";status=";
            sprintf(buf,"%u",(unsigned int)status);
            rv+=buf;
        }
        if(valueTypeFlag) {
            rv+=";valueType=";
            sprintf(buf,"%u",(unsigned int)valueType);
            rv+=buf;
        }
        if(timePolicyFlag) {
            rv+=";timePolicy=";
            sprintf(buf,"%u",(unsigned int)timePolicy);
            rv+=buf;
        }
        if(finalDateFlag) {
            rv+=";finalDate=";
            sprintf(buf,"%u",(unsigned int)finalDate);
            rv+=buf;
        }
        if(lifeTimeFlag) {
            rv+=";lifeTime=";
            sprintf(buf,"%u",(unsigned int)lifeTime);
            rv+=buf;
        }
        if(varNameFlag) {
            rv+=";varName=";
            rv+=varName;
        }
        if(intValueFlag) {
            rv+=";intValue=";
            sprintf(buf,"%u",(unsigned int)intValue);
            rv+=buf;
        }
        if(stringValueFlag) {
            rv+=";stringValue=";
            rv+=stringValue;
        }
        if(boolValueFlag) {
            rv+=";boolValue=";
            sprintf(buf,"%u",(unsigned int)boolValue);
            rv+=buf;
        }
        if(dateValueFlag) {
            rv+=";dateValue=";
            sprintf(buf,"%u",(unsigned int)dateValue);
            rv+=buf;
        }
        return rv;
    }

    /*
    template <class DataStream> uint32_t length()const
    {
        uint32_t rv=0;
        if (statusFlag) {
            rv+=DataStream::tagTypeSize;
            rv+=DataStream::lengthTypeSize;
            rv+=DataStream::fieldSize(status);
        }
        if (valueTypeFlag) {
            rv+=DataStream::tagTypeSize;
            rv+=DataStream::lengthTypeSize;
            rv+=DataStream::fieldSize(valueType);
        }
        if (timePolicyFlag) {
            rv+=DataStream::tagTypeSize;
            rv+=DataStream::lengthTypeSize;
            rv+=DataStream::fieldSize(timePolicy);
        }
        if (finalDateFlag) {
            rv+=DataStream::tagTypeSize;
            rv+=DataStream::lengthTypeSize;
            rv+=DataStream::fieldSize(finalDate);
        }
        if (lifeTimeFlag) {
            rv+=DataStream::tagTypeSize;
            rv+=DataStream::lengthTypeSize;
            rv+=DataStream::fieldSize(lifeTime);
        }
        if (varNameFlag) {
            rv+=DataStream::tagTypeSize;
            rv+=DataStream::lengthTypeSize;
            rv+=DataStream::fieldSize(varName);
        }
        if (intValueFlag) {
            rv+=DataStream::tagTypeSize;
            rv+=DataStream::lengthTypeSize;
            rv+=DataStream::fieldSize(intValue);
        }
        if (stringValueFlag) {
            rv+=DataStream::tagTypeSize;
            rv+=DataStream::lengthTypeSize;
            rv+=DataStream::fieldSize(stringValue);
        }
        if (boolValueFlag) {
            rv+=DataStream::tagTypeSize;
            rv+=DataStream::lengthTypeSize;
            rv+=DataStream::fieldSize(boolValue);
        }
        if (dateValueFlag) {
            rv+=DataStream::tagTypeSize;
            rv+=DataStream::lengthTypeSize;
            rv+=DataStream::fieldSize(dateValue);
        }
        return rv;
    }
     */

    uint8_t getStatus() const
        throw (FieldIsNullException)
    {
        if (!statusFlag) {
            throw FieldIsNullException("status");
        }
        return status;
    }
    void setStatus(uint8_t value)
    {
        status=value;
        statusFlag=true;
    }
    bool hasStatus()const
    {
        return statusFlag;
    }
    uint8_t getValueType() const
        throw (FieldIsNullException)
    {
        if (!valueTypeFlag) {
            throw FieldIsNullException("valueType");
        }
        return valueType;
    }
    void setValueType(uint8_t value)
    {
        valueType=value;
        valueTypeFlag=true;
    }
    bool hasValueType()const
    {
        return valueTypeFlag;
    }
    uint8_t getTimePolicy() const
        throw (FieldIsNullException)
    {
        if (!timePolicyFlag) {
            throw FieldIsNullException("timePolicy");
        }
        return timePolicy;
    }
    void setTimePolicy(uint8_t value)
    {
        timePolicy=value;
        timePolicyFlag=true;
    }
    bool hasTimePolicy()const
    {
        return timePolicyFlag;
    }
    uint32_t getFinalDate() const
        throw (FieldIsNullException)
    {
        if (!finalDateFlag) {
            throw FieldIsNullException("finalDate");
        }
        return finalDate;
    }
    void setFinalDate(uint32_t value)
    {
        finalDate=value;
        finalDateFlag=true;
    }
    bool hasFinalDate()const
    {
        return finalDateFlag;
    }
    uint32_t getLifeTime() const
        throw (FieldIsNullException)
    {
        if (!lifeTimeFlag) {
            throw FieldIsNullException("lifeTime");
        }
        return lifeTime;
    }
    void setLifeTime(uint32_t value)
    {
        lifeTime=value;
        lifeTimeFlag=true;
    }
    bool hasLifeTime()const
    {
        return lifeTimeFlag;
    }
    const std::string& getVarName() const
        throw (FieldIsNullException)
    {
        if (!varNameFlag) {
            throw FieldIsNullException("varName");
        }
        return varName;
    }
    void setVarName(const std::string& value)
    {
        varName=value;
        varNameFlag=true;
    }
    bool hasVarName()const
    {
        return varNameFlag;
    }
    uint32_t getIntValue() const
        throw (FieldIsNullException)
    {
        if (!intValueFlag) {
            throw FieldIsNullException("intValue");
        }
        return intValue;
    }
    void setIntValue(uint32_t value)
    {
        intValue=value;
        intValueFlag=true;
    }
    bool hasIntValue()const
    {
        return intValueFlag;
    }
    const std::string& getStringValue() const
        throw (FieldIsNullException)
    {
        if (!stringValueFlag) {
            throw FieldIsNullException("stringValue");
        }
        return stringValue;
    }
    void setStringValue(const std::string& value)
    {
        stringValue=value;
        stringValueFlag=true;
    }
    bool hasStringValue()const
    {
        return stringValueFlag;
    }
    uint8_t getBoolValue() const
        throw (FieldIsNullException)
    {
        if (!boolValueFlag) {
            throw FieldIsNullException("boolValue");
        }
        return boolValue;
    }
    void setBoolValue(uint8_t value)
    {
        boolValue=value;
        boolValueFlag=true;
    }
    bool hasBoolValue()const
    {
        return boolValueFlag;
    }
    uint32_t getDateValue() const
        throw (FieldIsNullException)
    {
        if (!dateValueFlag) {
            throw FieldIsNullException("dateValue");
        }
        return dateValue;
    }
    void setDateValue(uint32_t value)
    {
        dateValue=value;
        dateValueFlag=true;
    }
    bool hasDateValue()const
    {
        return dateValueFlag;
    }

    template <class Proto, class DataStream>
        void serialize( const Proto& proto, DataStream& ds ) const throw (PvapException)
    {
        checkFields();
        // mandatory fields
        printf( "write pos=%d field=%d\n", ds.getPos(), statusTag );
        ds.writeTag(statusTag);
        ds.writeByteLV(status);
        printf( "write pos=%d field=%d\n", ds.getPos(), valueTypeTag );
        ds.writeTag(valueTypeTag);
        ds.writeByteLV(valueType);
        printf( "write pos=%d field=%d\n", ds.getPos(), timePolicyTag );
        ds.writeTag(timePolicyTag);
        ds.writeByteLV(timePolicy);
        printf( "write pos=%d field=%d\n", ds.getPos(), finalDateTag );
        ds.writeTag(finalDateTag);
        ds.writeInt32LV(finalDate);
        printf( "write pos=%d field=%d\n", ds.getPos(), lifeTimeTag );
        ds.writeTag(lifeTimeTag);
        ds.writeInt32LV(lifeTime);
        printf( "write pos=%d field=%d\n", ds.getPos(), varNameTag );
        ds.writeTag(varNameTag);
        ds.writeByteStringLV(varName);
        // optional fields
        if (intValueFlag) {
            printf( "write pos=%d field=%d\n", ds.getPos(), intValueTag );
            ds.writeTag(intValueTag);
            ds.writeInt32LV(intValue);
        }
        if (stringValueFlag) {
            printf( "write pos=%d field=%d\n", ds.getPos(), stringValueTag );
            ds.writeTag(stringValueTag);
            ds.writeByteStringLV(stringValue);
        }
        if (boolValueFlag) {
            printf( "write pos=%d field=%d\n", ds.getPos(), boolValueTag );
            ds.writeTag(boolValueTag);
            ds.writeByteLV(boolValue);
        }
        if (dateValueFlag) {
            printf( "write pos=%d field=%d\n", ds.getPos(), dateValueTag );
            ds.writeTag(dateValueTag);
            ds.writeInt32LV(dateValue);
        }
    }

    template <class Proto, class DataStream> void deserialize(const Proto& proto, DataStream& ds)
        throw (PvapException)
    {
        clear();
        while (true) {
            int pos = int(ds.getPos());
            int tag = ds.readTag();
            printf( "read pos=%d field=%d\n", pos, tag );
            if ( tag == -1 ) break;
            switch(tag) {
            case statusTag: {
                if (statusFlag) {
                    throw DuplicateFieldException("status");
                }
                status=ds.readByteLV();
                statusFlag=true;
                break;
            }
            case valueTypeTag: {
                if (valueTypeFlag) {
                    throw DuplicateFieldException("valueType");
                }
                valueType=ds.readByteLV();
                valueTypeFlag=true;
                break;
            }
            case timePolicyTag: {
                if (timePolicyFlag) {
                    throw DuplicateFieldException("timePolicy");
                }
                timePolicy=ds.readByteLV();
                timePolicyFlag=true;
                break;
            }
            case finalDateTag: {
                if (finalDateFlag) {
                    throw DuplicateFieldException("finalDate");
                }
                finalDate=ds.readInt32LV();
                finalDateFlag=true;
                break;
            }
            case lifeTimeTag: {
                if (lifeTimeFlag) {
                    throw DuplicateFieldException("lifeTime");
                }
                lifeTime=ds.readInt32LV();
                lifeTimeFlag=true;
                break;
            }
            case varNameTag: {
                if (varNameFlag) {
                    throw DuplicateFieldException("varName");
                }
                varName=ds.readByteStringLV();
                varNameFlag=true;
                break;
            }
            case intValueTag: {
                if (intValueFlag) {
                    throw DuplicateFieldException("intValue");
                }
                intValue=ds.readInt32LV();
                intValueFlag=true;
                break;
            }
            case stringValueTag: {
                if (stringValueFlag) {
                    throw DuplicateFieldException("stringValue");
                }
                stringValue=ds.readByteStringLV();
                stringValueFlag=true;
                break;
            }
            case boolValueTag: {
                if (boolValueFlag) {
                    throw DuplicateFieldException("boolValue");
                }
                boolValue=ds.readByteLV();
                boolValueFlag=true;
                break;
            }
            case dateValueTag: {
                if (dateValueFlag) {
                    throw DuplicateFieldException("dateValue");
                }
                dateValue=ds.readInt32LV();
                dateValueFlag=true;
                break;
            }
            default:
                throw NotImplementedException("reaction of reading unknown");
            }
        }
        checkFields();
    }

    uint32_t getSeqNum() const
    {
        return seqNum;
    }
 
    void setSeqNum(uint32_t value)
    {
        seqNum=value;
    }

protected:
    void checkFields() const throw (MandatoryFieldMissingException)
    {
        // checking mandatory fields
        if (!statusFlag) {
            char buf[256];
            snprintf( buf, sizeof(buf), "field=%s msg=%s", "status", "BC_GET_RESP");
            throw MandatoryFieldMissingException(buf);
        }
        if (!valueTypeFlag) {
            char buf[256];
            snprintf( buf, sizeof(buf), "field=%s msg=%s", "valueType", "BC_GET_RESP");
            throw MandatoryFieldMissingException(buf);
        }
        if (!timePolicyFlag) {
            char buf[256];
            snprintf( buf, sizeof(buf), "field=%s msg=%s", "timePolicy", "BC_GET_RESP");
            throw MandatoryFieldMissingException(buf);
        }
        if (!finalDateFlag) {
            char buf[256];
            snprintf( buf, sizeof(buf), "field=%s msg=%s", "finalDate", "BC_GET_RESP");
            throw MandatoryFieldMissingException(buf);
        }
        if (!lifeTimeFlag) {
            char buf[256];
            snprintf( buf, sizeof(buf), "field=%s msg=%s", "lifeTime", "BC_GET_RESP");
            throw MandatoryFieldMissingException(buf);
        }
        if (!varNameFlag) {
            char buf[256];
            snprintf( buf, sizeof(buf), "field=%s msg=%s", "varName", "BC_GET_RESP");
            throw MandatoryFieldMissingException(buf);
        }
        // checking optional fields
        if (!intValueFlag
            && (valueType==1)
            ) {
            char buf[256];
            snprintf( buf, sizeof(buf), "field=%s msg=%s", "intValue", "BC_GET_RESP");
            throw MandatoryFieldMissingException(buf);
        }
        if (!stringValueFlag
            && (valueType==2)
            ) {
            char buf[256];
            snprintf( buf, sizeof(buf), "field=%s msg=%s", "stringValue", "BC_GET_RESP");
            throw MandatoryFieldMissingException(buf);
        }
        if (!boolValueFlag
            && (valueType==3)
            ) {
            char buf[256];
            snprintf( buf, sizeof(buf), "field=%s msg=%s", "boolValue", "BC_GET_RESP");
            throw MandatoryFieldMissingException(buf);
        }
        if (!dateValueFlag
            && (valueType==4)
            ) {
            char buf[256];
            snprintf( buf, sizeof(buf), "field=%s msg=%s", "dateValue", "BC_GET_RESP");
            throw MandatoryFieldMissingException(buf);
        }
    }

protected:
    //static const uint8_t versionMajor=2;
    //static const uint8_t versionMinor=0;

    static const int statusTag=1;
    static const int valueTypeTag=6;
    static const int timePolicyTag=7;
    static const int finalDateTag=8;
    static const int lifeTimeTag=9;
    static const int varNameTag=5;
    static const int intValueTag=10;
    static const int stringValueTag=11;
    static const int boolValueTag=12;
    static const int dateValueTag=13;

    uint32_t seqNum;

    uint8_t status;
    uint8_t valueType;
    uint8_t timePolicy;
    uint32_t finalDate;
    uint32_t lifeTime;
    std::string varName;
    uint32_t intValue;
    std::string stringValue;
    uint8_t boolValue;
    uint32_t dateValue;

    bool statusFlag;
    bool valueTypeFlag;
    bool timePolicyFlag;
    bool finalDateFlag;
    bool lifeTimeFlag;
    bool varNameFlag;
    bool intValueFlag;
    bool stringValueFlag;
    bool boolValueFlag;
    bool dateValueFlag;
};

} // namespace scag
} // namespace pvss
} // namespace pvap
#endif
