// NOTE: Do NOT edit this file (it is auto-generated).
// Instead, edit message-cpp.tmpl and regenerate.

#ifndef __SCAG_PVSS_PVAP_PC_AUTH_HPP__
#define __SCAG_PVSS_PVAP_PC_AUTH_HPP__

#include "util/int.h"
#include <string>
#include "Exceptions.h"
#include "TypeId.h"


namespace scag{
namespace pvss{
namespace pvap{

// class PVAP;

class PC_AUTH  
{
public:
    PC_AUTH()
    {
        clear();
    }
    void clear()
    {
        protocolVersionFlag=false;
        loginFlag=false;
        passwordFlag=false;
        nameFlag=false;
    }

    std::string toString() const
    {
        std::string rv("PC_AUTH:");
        char buf[32];
        sprintf(buf,"seqNum=%d",seqNum);
        rv+=buf;
        if(protocolVersionFlag) {
            rv+=";protocolVersion=";
            sprintf(buf,"%u",(unsigned int)protocolVersion);
            rv+=buf;
        }
        if(loginFlag) {
            rv+=";login=";
            rv+=login;
        }
        if(passwordFlag) {
            rv+=";password=";
            rv+=password;
        }
        if(nameFlag) {
            rv+=";name=";
            rv+=name;
        }
        return rv;
    }

    /*
    template <class DataStream> uint32_t length()const
    {
        uint32_t rv=0;
        if (protocolVersionFlag) {
            rv+=DataStream::tagTypeSize;
            rv+=DataStream::lengthTypeSize;
            rv+=DataStream::fieldSize(protocolVersion);
        }
        if (loginFlag) {
            rv+=DataStream::tagTypeSize;
            rv+=DataStream::lengthTypeSize;
            rv+=DataStream::fieldSize(login);
        }
        if (passwordFlag) {
            rv+=DataStream::tagTypeSize;
            rv+=DataStream::lengthTypeSize;
            rv+=DataStream::fieldSize(password);
        }
        if (nameFlag) {
            rv+=DataStream::tagTypeSize;
            rv+=DataStream::lengthTypeSize;
            rv+=DataStream::fieldSize(name);
        }
        return rv;
    }
     */

    uint8_t getProtocolVersion() const
        throw (FieldIsNullException)
    {
        if (!protocolVersionFlag) {
            throw FieldIsNullException("protocolVersion");
        }
        return protocolVersion;
    }
    void setProtocolVersion(uint8_t value)
    {
        protocolVersion=value;
        protocolVersionFlag=true;
    }
    bool hasProtocolVersion()const
    {
        return protocolVersionFlag;
    }
    const std::string& getLogin() const
        throw (FieldIsNullException)
    {
        if (!loginFlag) {
            throw FieldIsNullException("login");
        }
        return login;
    }
    void setLogin(const std::string& value)
    {
        login=value;
        loginFlag=true;
    }
    bool hasLogin()const
    {
        return loginFlag;
    }
    const std::string& getPassword() const
        throw (FieldIsNullException)
    {
        if (!passwordFlag) {
            throw FieldIsNullException("password");
        }
        return password;
    }
    void setPassword(const std::string& value)
    {
        password=value;
        passwordFlag=true;
    }
    bool hasPassword()const
    {
        return passwordFlag;
    }
    const std::string& getName() const
        throw (FieldIsNullException)
    {
        if (!nameFlag) {
            throw FieldIsNullException("name");
        }
        return name;
    }
    void setName(const std::string& value)
    {
        name=value;
        nameFlag=true;
    }
    bool hasName()const
    {
        return nameFlag;
    }

    template <class Proto, class DataStream>
        void serialize( const Proto& proto, DataStream& ds ) const throw (PvapException)
    {
        checkFields();
        // mandatory fields
        printf( "write pos=%d field=%d\n", ds.getPos(), protocolVersionTag );
        ds.writeTag(protocolVersionTag);
        ds.writeByteLV(protocolVersion);
        printf( "write pos=%d field=%d\n", ds.getPos(), loginTag );
        ds.writeTag(loginTag);
        ds.writeByteStringLV(login);
        printf( "write pos=%d field=%d\n", ds.getPos(), passwordTag );
        ds.writeTag(passwordTag);
        ds.writeByteStringLV(password);
        printf( "write pos=%d field=%d\n", ds.getPos(), nameTag );
        ds.writeTag(nameTag);
        ds.writeByteStringLV(name);
        // optional fields
    }

    template <class Proto, class DataStream> void deserialize(const Proto& proto, DataStream& ds)
        throw (PvapException)
    {
        clear();
        while (true) {
            int pos = int(ds.getPos());
            int tag = ds.readTag();
            printf( "read pos=%d field=%d\n", pos, tag );
            if ( tag == -1 ) break;
            switch(tag) {
            case protocolVersionTag: {
                if (protocolVersionFlag) {
                    throw DuplicateFieldException("protocolVersion");
                }
                protocolVersion=ds.readByteLV();
                protocolVersionFlag=true;
                break;
            }
            case loginTag: {
                if (loginFlag) {
                    throw DuplicateFieldException("login");
                }
                login=ds.readByteStringLV();
                loginFlag=true;
                break;
            }
            case passwordTag: {
                if (passwordFlag) {
                    throw DuplicateFieldException("password");
                }
                password=ds.readByteStringLV();
                passwordFlag=true;
                break;
            }
            case nameTag: {
                if (nameFlag) {
                    throw DuplicateFieldException("name");
                }
                name=ds.readByteStringLV();
                nameFlag=true;
                break;
            }
            default:
                throw NotImplementedException("reaction of reading unknown");
            }
        }
        checkFields();
    }

    uint32_t getSeqNum() const
    {
        return seqNum;
    }
 
    void setSeqNum(uint32_t value)
    {
        seqNum=value;
    }

protected:
    void checkFields() const throw (MandatoryFieldMissingException)
    {
        // checking mandatory fields
        if (!protocolVersionFlag) {
            char buf[256];
            snprintf( buf, sizeof(buf), "field=%s msg=%s", "protocolVersion", "PC_AUTH");
            throw MandatoryFieldMissingException(buf);
        }
        if (!loginFlag) {
            char buf[256];
            snprintf( buf, sizeof(buf), "field=%s msg=%s", "login", "PC_AUTH");
            throw MandatoryFieldMissingException(buf);
        }
        if (!passwordFlag) {
            char buf[256];
            snprintf( buf, sizeof(buf), "field=%s msg=%s", "password", "PC_AUTH");
            throw MandatoryFieldMissingException(buf);
        }
        if (!nameFlag) {
            char buf[256];
            snprintf( buf, sizeof(buf), "field=%s msg=%s", "name", "PC_AUTH");
            throw MandatoryFieldMissingException(buf);
        }
        // checking optional fields
    }

protected:
    //static const uint8_t versionMajor=2;
    //static const uint8_t versionMinor=0;

    static const int protocolVersionTag=15;
    static const int loginTag=16;
    static const int passwordTag=17;
    static const int nameTag=18;

    uint32_t seqNum;

    uint8_t protocolVersion;
    std::string login;
    std::string password;
    std::string name;

    bool protocolVersionFlag;
    bool loginFlag;
    bool passwordFlag;
    bool nameFlag;
};

} // namespace scag
} // namespace pvss
} // namespace pvap
#endif
