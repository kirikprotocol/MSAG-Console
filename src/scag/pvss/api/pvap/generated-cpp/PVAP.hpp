// NOTE: Do NOT edit this file (it is auto-generated).
// Instead, edit proto-cpp.tmpl and regenerate.

#ifndef __SCAG_PVSS_PVAP_PVAP_HPP__
#define __SCAG_PVSS_PVAP_PVAP_HPP__

#include <memory>
#include "scag/pvss/api/pvap/BufferReader.h"
#include "scag/pvss/api/pvap/BufferWriter.h"
#include "scag/pvss/api/pvap/Exceptions.h"
#include "PC_ERR_RESP.hpp"
#include "PC_PING.hpp"
#include "PC_PING_RESP.hpp"
#include "PC_AUTH.hpp"
#include "PC_AUTH_RESP.hpp"
#include "PC_PROFILE.hpp"
#include "PC_PROFILE_RESP.hpp"

namespace scag2 {
namespace pvss {
namespace pvap {

class PVAP
{
public:
    enum {
        tag_PC_ERR_RESP=32768,
        tag_PC_PING=6,
        tag_PC_PING_RESP=32774,
        tag_PC_AUTH=10,
        tag_PC_AUTH_RESP=32778,
        tag_PC_PROFILE=16,
        tag_PC_PROFILE_RESP=32784,
        tag_NO_TAG = 0xffff
    };

    class Handler
    {
    public:
        // virtual bool hasSeqNum( uint32_t seqNum ) const = 0;
        virtual void handle( PC_ERR_RESP& obj ) = 0;
        virtual void handle( PC_PING& obj ) = 0;
        virtual void handle( PC_PING_RESP& obj ) = 0;
        virtual void handle( PC_AUTH& obj ) = 0;
        virtual void handle( PC_AUTH_RESP& obj ) = 0;
        virtual void handle( PC_PROFILE& obj ) = 0;
        virtual void handle( PC_PROFILE_RESP& obj ) = 0;
    };

    PVAP( unsigned options = 0 ) : handler(0), options_(options) {}

    PVAP( Handler* newHandler, unsigned options = 0 ) : handler(newHandler), options_(options) {}

    /*
    void assignHandler( Handler* newHandler)
    {
        handler=newHandler;
    }
     */

    inline unsigned getOptions() const { return options_; }
    inline void setOptions( unsigned opt ) { options_ = opt; }

    void decodeMessage( BufferReader& ss ) throw (PvapException)
    {
        uint32_t seqNum = -1;
        seqNum = ss.readInt();
        // if ( ! handler->hasSeqNum(seqNum) ) throw UnexpectedSeqNumException(seqNum);
        int tag = ss.readTag();
        switch(tag) {
        case tag_PC_ERR_RESP: {
            // printf( "tag %d (%s)\n", tag, "PC_ERR_RESP" );
            PC_ERR_RESP msg;
            msg.setSeqNum(seqNum);
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        case tag_PC_PING: {
            // printf( "tag %d (%s)\n", tag, "PC_PING" );
            PC_PING msg;
            msg.setSeqNum(seqNum);
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        case tag_PC_PING_RESP: {
            // printf( "tag %d (%s)\n", tag, "PC_PING_RESP" );
            PC_PING_RESP msg;
            msg.setSeqNum(seqNum);
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        case tag_PC_AUTH: {
            // printf( "tag %d (%s)\n", tag, "PC_AUTH" );
            PC_AUTH msg;
            msg.setSeqNum(seqNum);
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        case tag_PC_AUTH_RESP: {
            // printf( "tag %d (%s)\n", tag, "PC_AUTH_RESP" );
            PC_AUTH_RESP msg;
            msg.setSeqNum(seqNum);
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        case tag_PC_PROFILE: {
            // printf( "tag %d (%s)\n", tag, "PC_PROFILE" );
            PC_PROFILE msg;
            msg.setSeqNum(seqNum);
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        case tag_PC_PROFILE_RESP: {
            // printf( "tag %d (%s)\n", tag, "PC_PROFILE_RESP" );
            PC_PROFILE_RESP msg;
            msg.setSeqNum(seqNum);
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        default:
            throw InvalidMessageTypeException(seqNum,tag);
        }
    }

    void encodeMessage( const PC_ERR_RESP& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeInt(msg.getSeqNum());
        ss.writeTag(tag_PC_ERR_RESP);
        msg.serialize(*this,ss);
    }

    void encodeMessage( const PC_PING& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeInt(msg.getSeqNum());
        ss.writeTag(tag_PC_PING);
        msg.serialize(*this,ss);
    }

    void encodeMessage( const PC_PING_RESP& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeInt(msg.getSeqNum());
        ss.writeTag(tag_PC_PING_RESP);
        msg.serialize(*this,ss);
    }

    void encodeMessage( const PC_AUTH& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeInt(msg.getSeqNum());
        ss.writeTag(tag_PC_AUTH);
        msg.serialize(*this,ss);
    }

    void encodeMessage( const PC_AUTH_RESP& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeInt(msg.getSeqNum());
        ss.writeTag(tag_PC_AUTH_RESP);
        msg.serialize(*this,ss);
    }

    void encodeMessage( const PC_PROFILE& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeInt(msg.getSeqNum());
        ss.writeTag(tag_PC_PROFILE);
        msg.serialize(*this,ss);
    }

    void encodeMessage( const PC_PROFILE_RESP& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeInt(msg.getSeqNum());
        ss.writeTag(tag_PC_PROFILE_RESP);
        msg.serialize(*this,ss);
    }

protected:
    Handler* handler; // unowned
    unsigned options_;
};

}
}
}

#endif
