// NOTE: Do NOT edit this file (it is auto-generated).
// Instead, edit proto-cpp.tmpl and regenerate.

#ifndef __SCAG_PVSS_PVAP_PVAPPROF_HPP__
#define __SCAG_PVSS_PVAP_PVAPPROF_HPP__

#include <memory>
#include "scag/pvss/api/pvap/BufferReader.h"
#include "scag/pvss/api/pvap/BufferWriter.h"
#include "scag/pvss/api/pvap/Exceptions.h"
#include "BC_DEL.hpp"
#include "BC_DEL_RESP.hpp"
#include "BC_SET.hpp"
#include "BC_SET_RESP.hpp"
#include "BC_GET.hpp"
#include "BC_GET_RESP.hpp"
#include "BC_INC.hpp"
#include "BC_INC_RESP.hpp"
#include "BC_INC_MOD.hpp"
#include "BC_BATCH.hpp"
#include "BC_BATCH_RESP.hpp"
#include "BC_GETPROF.hpp"
#include "BC_GETPROF_RESP.hpp"

namespace scag2 {
namespace pvss {
namespace pvap {

class PVAPPROF
{
public:
    enum {
        tag_BC_DEL=1,
        tag_BC_DEL_RESP=32769,
        tag_BC_SET=2,
        tag_BC_SET_RESP=32770,
        tag_BC_GET=3,
        tag_BC_GET_RESP=32771,
        tag_BC_INC=4,
        tag_BC_INC_RESP=32772,
        tag_BC_INC_MOD=5,
        tag_BC_BATCH=7,
        tag_BC_BATCH_RESP=32775,
        tag_BC_GETPROF=8,
        tag_BC_GETPROF_RESP=32776,
        tag_NO_TAG = 0xffff
    };

    class Handler
    {
    public:
        // virtual bool hasSeqNum( uint32_t seqNum ) const = 0;
        virtual void handle( BC_DEL& obj ) = 0;
        virtual void handle( BC_DEL_RESP& obj ) = 0;
        virtual void handle( BC_SET& obj ) = 0;
        virtual void handle( BC_SET_RESP& obj ) = 0;
        virtual void handle( BC_GET& obj ) = 0;
        virtual void handle( BC_GET_RESP& obj ) = 0;
        virtual void handle( BC_INC& obj ) = 0;
        virtual void handle( BC_INC_RESP& obj ) = 0;
        virtual void handle( BC_INC_MOD& obj ) = 0;
        virtual void handle( BC_BATCH& obj ) = 0;
        virtual void handle( BC_BATCH_RESP& obj ) = 0;
        virtual void handle( BC_GETPROF& obj ) = 0;
        virtual void handle( BC_GETPROF_RESP& obj ) = 0;
    };

    PVAPPROF( unsigned options = 0 ) : handler(0), options_(options) {}

    PVAPPROF( Handler* newHandler, unsigned options = 0 ) : handler(newHandler), options_(options) {}

    /*
    void assignHandler( Handler* newHandler)
    {
        handler=newHandler;
    }
     */

    inline unsigned getOptions() const { return options_; }
    inline void setOptions( unsigned opt ) { options_ = opt; }

    void decodeMessage( BufferReader& ss ) throw (PvapException)
    {
        uint32_t seqNum = -1;
        // if ( ! handler->hasSeqNum(seqNum) ) throw UnexpectedSeqNumException(seqNum);
        int tag = ss.readTag();
        switch(tag) {
        case tag_BC_DEL: {
            // printf( "tag %d (%s)\n", tag, "BC_DEL" );
            BC_DEL msg;
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        case tag_BC_DEL_RESP: {
            // printf( "tag %d (%s)\n", tag, "BC_DEL_RESP" );
            BC_DEL_RESP msg;
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        case tag_BC_SET: {
            // printf( "tag %d (%s)\n", tag, "BC_SET" );
            BC_SET msg;
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        case tag_BC_SET_RESP: {
            // printf( "tag %d (%s)\n", tag, "BC_SET_RESP" );
            BC_SET_RESP msg;
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        case tag_BC_GET: {
            // printf( "tag %d (%s)\n", tag, "BC_GET" );
            BC_GET msg;
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        case tag_BC_GET_RESP: {
            // printf( "tag %d (%s)\n", tag, "BC_GET_RESP" );
            BC_GET_RESP msg;
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        case tag_BC_INC: {
            // printf( "tag %d (%s)\n", tag, "BC_INC" );
            BC_INC msg;
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        case tag_BC_INC_RESP: {
            // printf( "tag %d (%s)\n", tag, "BC_INC_RESP" );
            BC_INC_RESP msg;
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        case tag_BC_INC_MOD: {
            // printf( "tag %d (%s)\n", tag, "BC_INC_MOD" );
            BC_INC_MOD msg;
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        case tag_BC_BATCH: {
            // printf( "tag %d (%s)\n", tag, "BC_BATCH" );
            BC_BATCH msg;
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        case tag_BC_BATCH_RESP: {
            // printf( "tag %d (%s)\n", tag, "BC_BATCH_RESP" );
            BC_BATCH_RESP msg;
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        case tag_BC_GETPROF: {
            // printf( "tag %d (%s)\n", tag, "BC_GETPROF" );
            BC_GETPROF msg;
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        case tag_BC_GETPROF_RESP: {
            // printf( "tag %d (%s)\n", tag, "BC_GETPROF_RESP" );
            BC_GETPROF_RESP msg;
            msg.deserialize(*this,ss);
            handler->handle(msg);
            break;
        }
        default:
            throw InvalidMessageTypeException(seqNum,tag);
        }
    }

    void encodeMessage( const BC_DEL& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeTag(tag_BC_DEL);
        msg.serialize(*this,ss);
    }

    void encodeMessage( const BC_DEL_RESP& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeTag(tag_BC_DEL_RESP);
        msg.serialize(*this,ss);
    }

    void encodeMessage( const BC_SET& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeTag(tag_BC_SET);
        msg.serialize(*this,ss);
    }

    void encodeMessage( const BC_SET_RESP& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeTag(tag_BC_SET_RESP);
        msg.serialize(*this,ss);
    }

    void encodeMessage( const BC_GET& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeTag(tag_BC_GET);
        msg.serialize(*this,ss);
    }

    void encodeMessage( const BC_GET_RESP& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeTag(tag_BC_GET_RESP);
        msg.serialize(*this,ss);
    }

    void encodeMessage( const BC_INC& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeTag(tag_BC_INC);
        msg.serialize(*this,ss);
    }

    void encodeMessage( const BC_INC_RESP& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeTag(tag_BC_INC_RESP);
        msg.serialize(*this,ss);
    }

    void encodeMessage( const BC_INC_MOD& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeTag(tag_BC_INC_MOD);
        msg.serialize(*this,ss);
    }

    void encodeMessage( const BC_BATCH& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeTag(tag_BC_BATCH);
        msg.serialize(*this,ss);
    }

    void encodeMessage( const BC_BATCH_RESP& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeTag(tag_BC_BATCH_RESP);
        msg.serialize(*this,ss);
    }

    void encodeMessage( const BC_GETPROF& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeTag(tag_BC_GETPROF);
        msg.serialize(*this,ss);
    }

    void encodeMessage( const BC_GETPROF_RESP& msg, BufferWriter& ss ) const
        throw (PvapException)
    {
        ss.writeTag(tag_BC_GETPROF_RESP);
        msg.serialize(*this,ss);
    }

protected:
    Handler* handler; // unowned
    unsigned options_;
};

}
}
}

#endif
