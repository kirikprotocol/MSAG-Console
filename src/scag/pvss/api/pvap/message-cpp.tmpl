// NOTE: Do NOT edit this file (it is auto-generated).
// Instead, edit message-cpp.tmpl and regenerate.

#ifndef __SCAG_PVSS_PVAP_$var message.name:uc$_HPP__
#define __SCAG_PVSS_PVAP_$var message.name:uc$_HPP__

#include "util/int.h"
#include <string>
#include "scag/pvss/api/pvap/Exceptions.h"
$foreach field$
$select field.type$
$case byte$
$case uint16$
$case uint32$
$case uint64$
$case string$
$case ascii$
$case utf8$
$case bool$
$case nested$#include "$var field.typename$.hpp"
$default$// #include "scag/pvss/api/pvap/$var field.type$.h"
$-select$
$ifdef field.helperClass$#include "scag/pvss/api/pvap/$var field.helperClass$.h"$-ifdef$
$-foreach$
#include "scag/pvss/api/packets/$var message.inheritsFrom$.h"
$ifdef message.command$#include "scag/pvss/api/packets/$var message.command$.h"$-ifdef$

$macro type$$pack$
$select %1$
 $case byte$uint8_t
 $case uint16$uint16_t
 $case uint32$uint32_t
 $case uint64$uint64_r
 $case string$const std::string&
 $case ascii$const std::string&
 $case utf8$const std::string&
 $case bool$bool
 $case nested$const $var field.typename$&
 $default$const $var field.type$&
$-select$
$-pack$$-macro$

$macro checker$$pack$
$if !field.isTransient$data_$-if$$if field.isTransient$this$-if$->$if field.useProfile$getProfileKey().$-if$$ifdef field.useChecker$$var field.useChecker$$-ifdef$$ifndef field.useChecker$has$var field.name:ucf$$-ifndef$
$-pack$$-macro$
$macro getter$$pack$
$if !field.isTransient$data_$-if$$if field.isTransient$this$-if$->$if field.useProfile$getProfileKey().$-if$$ifdef field.useGetter$$var field.useGetter$$-ifdef$$ifndef field.useGetter$get$var field.name:ucf$$-ifndef$
$-pack$$-macro$
$macro setter$$pack$
$if !field.isTransient$data_$-if$$if field.isTransient$this$-if$->$if field.useProfile$getProfileKey().$-if$$ifdef field.useSetter$$var field.useSetter$$-ifdef$$ifndef field.useSetter$set$var field.name:ucf$$-ifndef$
$-pack$$-macro$
$macro baseclass$$var message.inheritsFrom$$ifdef message.command$< $var message.command$ >$-ifdef$$-macro$

$foreach namespace$
namespace $var namespace${
$-foreach$

class $var protocol.name:ucf$;

class $var message.name$
{
protected:
$foreach field$
$if !field.isTransient$
    static const int $var field.name$Tag = $var field.tag$;
$-if$
$-foreach$

public:
    $var message.name$() :
    owned_(true),
    data_(new $expand baseclass$$ifdef message.command$(new $var message.command$)$-ifdef$)
    {
$foreach field$
$if field.isTransient$
        $var field.name$Flag = false;
$-if$
$-foreach$
    }

    $var message.name$( $expand baseclass$* other ) :
    owned_(false),
    data_(other)
    {
$foreach field$
$if field.isTransient$
        $var field.name$Flag = false;
$-if$
$-foreach$
    }

    ~$var message.name$() {
        if ( data_ && owned_ ) delete data_;
    }

    void clear()
    {
        if ( ! data_ ) return;
        data_->clear();
$foreach field$
$if field.isTransient$
        $var field.name$Flag=false;
$-if$
$-foreach$
    }

    $expand baseclass$* pop() {
        $expand baseclass$* rv = data_;
        data_ = 0;
        return rv;
    }

    std::string toString() const
    {
        return data_ ? data_->toString() : "";
    }

    template < class DataStream >
        void serialize( const $var protocol.name:ucf$& proto, DataStream& writer ) const throw (PvapException)
    {
        if ( ! data_ ) return;
        checkFields();
        // mandatory fields
$foreach field$
$if !field.isTransient$
$if field.mandatory$
        try {
            // printf( "write pos=%d field=%d\n", ds.getPos(), $var field.name$Tag );
            writer.writeTag($var field.name$Tag);
            $select field.type$
$case string$writer.writeStrLV($expand getter$());
$case ascii$writer.writeAsciiLV($expand getter$());
$case utf8$writer.writeUTFLV($expand getter$());
$case byte$writer.writeByteLV($expand getter$());
$case uint16$writer.writeShortLV($expand getter$());
$case uint32$writer.writeIntLV($expand getter$());
$case uint64$writer.writeLongLV($expand getter$());
$case bool$writer.writeBoolLV($expand getter$());
$case nested$throw NotImplementedException("$var field.name$");
$default${
$ifdef field.helperClass$
                $var field.helperClass$ helper( data_ );
                helper.serialize( proto, writer );
$-ifdef$
$ifndef field.helperClass$
                $expand getter$().serialize(proto,writer);
$-ifndef$                
            }
$-select$
        } catch ( exceptions::IOException& e ) {
            throw PvapSerializationException( data_->isRequest(),
                                              getSeqNum(),
                                              "writing field $var field.name$ in $var message.name$: %s",
                                              e.what() );
        }
$-if$
$-if$
$-foreach$
        // optional fields
$foreach field$
$if !field.isTransient$
$if field.optional$
        if ( $expand checker$() ) {
            // printf( "write pos=%d field=%d\n", writer.getPos(), $var field.name$Tag );
            try {
                writer.writeTag($var field.name$Tag);
                $select field.type$
$case byte$writer.writeByteLV($expand getter$());
$case uint16$writer.writeShortLV($expand getter$());
$case uint32$writer.writeIntLV($expand getter$());
$case uint64$writer.writeLongLV($expand getter$());
$case string$writer.writeStrLV($expand getter$());
$case ascii$writer.writeAsciiLV($expand getter$());
$case utf8$writer.writeUTFLV($expand getter$());
$case bool$writer.writeBoolLV($expand getter$());
$case nested$throw NotImplementedException("$var field.name$");
$default${
$ifdef field.helperClass$
                    $var field.helperClass$ helper( data_ );
                    helper.serialize(proto,writer);
$-ifdef$
$ifndef field.helperClass$
                    $expand getter$().serialize(proto,writer);
$-ifndef$                
                }
$-select$
            } catch ( exceptions::IOException& e ) {
                throw PvapSerializationException( data_->isRequest(),
                                                  getSeqNum(),
                                                  "writing field $var field.name$ in $var message.name$:",
                                                  e.what() );
            }
        }
$-if$
$-if$
$-foreach$
    }

    template <class DataStream> void deserialize( $var protocol.name:ucf$& proto, DataStream& reader )
        throw (PvapException)
    {
        if ( ! data_ ) return;
        clear();
        int tag = -1;
        try {
            do {
                // int pos = int(reader.getPos());
                tag = reader.readTag();
                // printf( "read pos=%d field=%d\n", pos, tag );
                if ( tag == -1 ) break;
                switch(tag) {
$foreach field$
$if !field.isTransient$
                case $var field.name$Tag: {
$ifdef field.checkVar$
                    if ($var field.checkVar$Flag) {
                        throw DuplicateFieldException(data_->isRequest(),
                                                      "duplicate field $var field.name$ of $var message.name$", getSeqNum());
                    }
                    $var field.checkVar$Flag = true;
$-ifdef$
                    $select field.type$
$case byte$$expand setter$(reader.readByteLV());
$case uint16$$expand setter$(reader.readShortLV());
$case uint32$$expand setter$(reader.readIntLV());
$case uint64$$expand setter$(reader.readLongLV());
$case string$$expand setter$(reader.readStrLV());
$case ascii$$expand setter$(reader.readAsciiLV());
$case utf8$$expand setter$(reader.readUTFLV());
$case bool$$expand setter$(reader.readBoolLV());
$case nested$throw NotImplementedException("reading field $var field.name$ of $var message.name$ is not impl yet", getSeqNum());
$default$$ifndef field.helperClass$$var field.type$ temp;
                    temp.deserialize(proto,reader);
                    $expand setter$(temp);
$-ifndef$
$ifdef field.helperClass$$var field.helperClass$ helper(data_);
                    helper.deserialize(proto,reader);
$-ifdef$
$-select$
                    break;
                }
$-if$
$-foreach$
                default:
                    throw InvalidFieldTypeException(data_->isRequest(),"$var message.name$", getSeqNum(),tag);
                }
            } while ( true );
        } catch ( exceptions::IOException& e ) {
            throw PvapSerializationException( data_->isRequest(),
                                              getSeqNum(),
                                              "reading field tag=%d of $var message.name$: %s",
                                              tag, e.what() );
        }
        checkFields();
    }

    uint32_t getSeqNum() const {
        return 
$if options.hasSeqNum$
            data_ ? data_->getSeqNum() : 
$-if$
        uint32_t(-1);
    }

$if options.hasSeqNum$
    void setSeqNum( uint32_t seqNum ) {
        if (data_) data_->setSeqNum(seqNum);
    }
$-if$

protected:
    void checkFields() const throw (PvapException)
    {
        // using parent check
        if ( !data_->isValid() ) {
            throw MessageIsBrokenException(data_->isRequest(), getSeqNum(), "message $var message.name$ is broken: %s",data_->toString().c_str());
        }
    }

private:
    $var message.name$( const $var message.name$& );
    $var message.name$& operator = ( const $var message.name$& );

protected:
    //static const uint8_t versionMajor=$var message.versionMajor$;
    //static const uint8_t versionMinor=$var message.versionMinor$;

    bool                owned_;
    $expand baseclass$* data_;
$foreach field$
$if field.isTransient$
    $pack$
  $select field.type$
  $case byte$uint8_t
  $case uint16$uint16_t
  $case uint32$uint32_t
  $case uint64$uint64_t
  $case string$std::string
  $case ascii$std::string
  $case utf8$std::string
  $case bool$bool
  $case nested$$var field.typename$
  $default$$var field.type$
  $-select$
  $var field.name$$-pack$;
$-if$
$-foreach$

$foreach field$
$if field.isTransient$
    bool $var field.name$Flag;
$-if$
$-foreach$
};

$foreach namespace$
} // namespace $var namespace$
$-foreach$
#endif
