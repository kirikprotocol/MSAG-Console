NOTE: this document is in UTF8.

                      Запрос сессии
                      -------------

Клиент (обработчик траспортной команды) имеет возможность запросить
сессию абонента посредством двух методов:
ActiveSession SessionManager::getSession( const SessionKey&     key,
                                          std::auto_ptr< Cmd >& cmd,
                                          bool                  create );

и
ActiveSession SessionManager::getSession( const SessionKey&     key,
                                          SCAGCommand*&         cmd,
                                          bool                  create );

Оба метода принимают в качестве аргументов ключ key сессии (номер абонента),
указатель на команду cmd, и флаг create, указывающий позволено ли создавать
сессию в случае ее отсутствия.

При этом первый метод должен использоваться там, где владение
транспортной командой должно передаваться вместе с ней (н-р, smpp),
а второй -- там, где владение командой внешнее (н-р, http).

Оба метода возвращают "умный" указатель ActiveSession, который
гарантирует вызов метода разблокирования сессии,
в деструкторе ActiveSession.

При невозможности вернуть сессию в данный момент, возвращается невалидный указатель.
Причины неуспеха могут быть разными, н-р сессия заблокирована
другой командой, сессия отсутствует и не может быть создана (create=false), и т.д.
Если сессия блокирована другой командой, то команда будет помещена в очередь
команд сессии, и при возврате из метода getSession указатель cmd будет обнулен.
В таком случае необходимо просто завершить обработку данной команды.
Ее обработка будет продолжена автоматически после разблокирования сессии.

SessionStore не специфицирует способ владения транспортной команды (т.е. не
определяет как и кем она должна быть уничтожена).  Вместо этого 
все транспортные команды _обязательно_ передаются в транспортную очередь.
Обработчик транспортных команд выбирает очередную команду из очереди
и после завершения ее обработки, уничтожает ее.

Внутри оба эти метода вызывают один и тот же метод SessionStore::fetchSession.
SessionStore содержит в себе кэш сессий, и дисковое хранилище сессий.

Ниже приводится алгоритм работы fetchSession:

1. Проверяется, что команда cmd содержит ссылку на сессию.  Если это так,
   то сессия должна быть уже заблокирована этой командой,
   и метод сразу же возвращает сессию, без блокировки кэша.
   (Если сессия заблокирована какой-либо другой командой -- это логическая ошибка).

2. Кэш блокируется (с разблокированием при выходе из метода).

3. Если SessionStore находится в остановленном состоянии -- возвращается 0.

4. Проверяется, если ли в кэше сессия с данным ключом key.
   Если такая сессия есть и она не заблокирована, то команда cmd блокирует
   сессию, сессия возвращается клиенту.
   
5. Если сессия есть в кэше и заблокирована другой командой, то команда cmd добавляется в
   очередь команд сессии, транспортная очередь уведомляется о потенциальной
   команде в ней, и клиенту возвращается 0.

6. Иначе сессия не найдена в кэше.
   Если запрещено создание сессии (create=false),
   и конфигурация SessionStore запрещает disk i/o, то возвращается 0.

7. Иначе создается новая сессия с данным ключом key и помещается в кэш.
   Сессия сразу же блокируется командой cmd.

8. Кэш разблокируется.

9. Если конфигурация SessionStore запрещает disk i/o, то вновь созданная сессия
   возвращается клиенту.

10. Иначе выполняется попытка закачки сессии с диска.
   Если закачка не удалась, и запрещено создание сессии (create=false), то
   возвращается 0.

11. Иначе если закачка не удалась, а создание сессии разрешено, то
    вновь созданная сессия возвращается клиенту.

12. Иначе закачка была успешна.  Если время жизни сессии истекло,
   то кэш блокируется, команда добавляется в конец очереди команд сессии,
   уведомляется транспортная очередь о потенциальной команде в ней, сессия блокируется
   специальной командой финализации и запускается механизм финализации сессии.
   Клиенту возвращается 0.

13. Если сессия была подгружена с диска в первый раз после запуска MSAG,
   и в ней нет персистентных операций, то выполняется очистка сессии.

14. Сессия возвращается клиенту.


                     Разблокирование сессии
                     ----------------------

Разблокирование сессии производится автоматически в деструкторе обьекта ActiveSession.
Также разблокирование сессии можно произвести, не дожидаясь деструктора,
вызвав метод ActiveSession::release().

Для разблокирования сессии ActiveSession вызывает метод
  SessionStore::releaseSession( Session& session )
со следующим алгоритмом:

1. Проверяется, что сессия блокирована, иначе это логическая ошибка.

2. Время последнего доступа (lastaccess) к сессии сбрасывается на текущее время.

3. Кэш блокируется (с разблокированием при выходе из метода).

4. Если необходимо сохранение сессии на диск, т.е. если
   конфигурация SessionStore разрешает disk i/o, и текущая операция в
   сессии -- персистентная, либо была завершена персистентная операция,
   то сессия сохраняется на диск.

5. Если очередь команд сессии не пуста, то из нее достается следующая команда.
   Сессия блокируется этой командой.

6. Кэш разблокируется.

7. Если сессия заблокирована (была следующая команда), то команда
   перемещается в транспортную очередь.  Если транспортная очередь
   остановлена, то все команды из очереди команд сессии перемещаются
   в транспортную очередь (для корректного их уничтожения), сессия
   разблокируется.

8. Если сессия разблокирована, то ее ключ регистрируется
   во входной очереди SessionManager в потоке завершения сессий,
   вызовом метода SessionManager::scheduleExpire(lastaccess, expiration, key).


                    Уничтожение/сброс на диск сессий
                    --------------------------------

Неиспользуемые сессии должны быть уничтожены, либо сброшены на диск,
в зависимости от времени завершения сессии (expiration time), времени
последнего доступа к сессии (lastaccess time), и настроек
SessionManager, в частности, ограничения на время
простоя сессии до ее сброса на диск (flushTimeLimit),
и ограничения на общее кол-во загруженных сессий до начала
их выдавливания на диск (flushCountLimit).

За своевременным уничтожением/сбросом на диск сессий следит
выделенный поток обработки в SessionManager.  

Ключ key неиспользуемой сессии, а также время ее завершения (expiration)
и время последнего доступа (lastaccess) передаются во входную очередь
этого потока вызовом метода
  SessionManager::scheduleExpire(lastaccess, expiration, key )
Для ускорения работы и уменьшения времени ожидания блокировок,
эти данные просто помещаются в конец очереди, без обработки.

SessionManager содержит в себе:
1. Список (expireList) всех зарегистрированных ключей с их временем
   завершения и временем последнего доступа;
2. Хэш (expireHash) для быстрого доступа к элементу списка по ключу сессии;
3. Карта std::map (expireMap) для упорядочивания элементов списка по времени
   завершения сессии.

Сессия может быть в двух состояниях: в оперативной памяти и сброшена на диск.
SessionManager распознает эти два состояния по времени последнего
доступа к сессии: если это время имеет специальное невалидное значение --
это признак что сессия сброшена на диск.

Алгоритм работы потока обработки неиспользуемых сессий SessionManager::Execute()
следующий (в цикле):

1. Запоминается состояние потока: "работа" или "остановка".

2. Производится разбор входной очереди.  Элемент вносится в список,
   а также индексируется в хэше и в карте для быстрого доступа.
   При этом автоматически убираются дублирующие ключи, обновляется
   информация о времени завершения и последнего доступа к сессии.

3. Если состояние было "работа", то составляется список (expireset) 
   ключей сессий, время которых подошло к завершению (иначе этот список пуст).
   В список попадают все ключи, время завершения которых прошло (меньше текущего).
   После помещения в список они стираются из всех структур данных.

4. Если имеются сессии в оперативной памяти и состояние "остановка",
   то все эти сессии попадают в список (flushset) сессий,
   которые необходимо сбросить на диск.

5. Иначе, если количество сессий в оперативной памяти больше
   сконфигурированного ограничения (flushCountLimit), либо самая старая
   из этих сессий пережила ограничение flushTimeLimit, то выполняется
   заполнение списка сессий, которые необходимо сбросить на диск.
   Все эти сессии помечаются как сброшенные на диск.

6. Если состояние было "остановка" и оба списка пусты, то выход из цикла.

7. Если оба списка пусты, то ожидаем либо до ближайшего времени 
   завершения сессии, либо некоторое заданное время, что ближе,
   и переходим на начало цикла.

8. Выполняется вызов SessionStore::expireSessions( expireset, flushset ).
   Переход на начало цикла.

В методе SessionStore::expireSession( expireset, flushset ) все ключи
обрабатываются по очереди:

1. Выбирается очередной ключ из expireset, а затем, когда этот список
   закончится, из flushset.  Ключи из expireset определяют сессии,
   которые требуют финализации, ключи из flushset требуют сброса сессии на диск.

2. Блокируется кэш (с разблокированием по переходу на начало цикла/выходу из цикла),
   в нем по ключу производится поиск сессии.

3. Если сессия не найдена и SessionStore в состоянии остановки,
   то переход на начало цикла.

4. Если сессия не найдена и требует финализации, и конфигурация
   SessionStore разрешает disk i/o, то выполняется попытка подкачки
   сессии с диска.  При этом, если сессия подгружается в первый раз
   в этом запуске MSAG, и в ней нет персистентных операций, 
   то требование финализации снимается, сессия просто удаляется
   из кэша и с диска, с переходом на начало цикла.

4. Иначе, если сессия не найдена, то переход на начало цикла.

5. Иначе сессия найдена (или успешно подгружена).
   Выполняется проверка текущей команды, блокирующей сессию.

6. Если сессия заблокирована какой-либо командой, кроме
   специальной финализирующей команды, то переход на начало цикла.

7. Если сессии требуется сброс на диск, но время последнего доступа
   к ней изменилось, либо время ее завершения в пределах 5 секунд,
   то сброс на диск не выполняется, переход на начало цикла.

8. Если сессии требуется финализация, но ее время завершения в будущем,
   то переход на начало цикла.

9. Иначе сессия блокируется специальной финализирующей командой.
   Кэш разблокируется.

10. Производится сброс на диск, если сессия требует этого, однако
   сброс не производится, если SessionStore в состоянии остановки,
   а в сессии нет персистентных операций.
   Проверяется наличие в очереди команд сессии новых команд, если
   они есть, то очередная команда из очереди блокирует сессию,
   и перемещается в транспортную очередь.  Иначе сессия удаляется
   из кэша.  Переход на начало цикла.

11. Иначе, если сессия требует финализации, то вызывается
   метод finalize(), который может забрать сессию на longcall.
   В этом случае производится переход на начало цикла.

12. иначе сессия удаляется с диска.

13. Проверяется наличие в очереди команд сессии новых команд, если
   они есть, то очередная команда из очереди блокирует сессию,
   и перемещается в транспортную очередь.  Иначе сессия удаляется
   из кэша.

14. Переход на начало цикла.
