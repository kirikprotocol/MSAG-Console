// NOTE: Do NOT edit this file (it is auto-generated).
// Instead, edit message-cpp.tmpl and regenerate.

#ifndef SCAG_BILL_EWALLET_STREAM_$var message.name:uc$_HPP
#define SCAG_BILL_EWALLET_STREAM_$var message.name:uc$_HPP

#include "util/int.h"
#include <string>
#include "scag/bill/ewallet/Status.h"
#include "scag/exc/IOException.h"
#include "scag/bill/ewallet/Exception.h"

$macro typeref$$pack$
$select %1$
 $case byte$uint8_t
 $case uint16$uint16_t
 $case int32$int32_t
 $case int64$int64_t
 $case ascii$const std::string&
 $case utf8$const std::string&
 $case bool$bool
$-select$
$-pack$$-macro$

$foreach namespace$
namespace $var namespace$ {
$-foreach$

class $var protocol.name:ucf$;

class $var message.name$
{
protected:
$foreach field$
    static const int $var field.name$Tag = $var field.tag$;
$-foreach$

public:
    $var message.name$()
    {
$foreach field$
        $var field.name$Flag = false;
$-foreach$
    }

    ~$var message.name$() {
    }

    void clear()
    {
$foreach field$
        $var field.name$Flag=false;
$-foreach$
    }

    std::string toString() const
    {
        std::string res;
        res.reserve(200);
        res.append("$var message.name$");
$if options.hasSeqNum$
        {
            char buf[40];
            sprintf(buf," seq=%u",unsigned(getSeqNum()));
            res.append(buf);
        }
$-if$
$foreach field$
        if ( $var field.name$Flag ) {
            res.append(" $var field.name$=");
            $select field.type$
$case ascii$res.push_back('"'); res.append($var field.name$); res.push_back('"');
$case utf8$res.push_back('"'); res.append($var field.name$); res.push_back('"');
$case byte$char buf[10]; sprintf(buf,"%u",unsigned($var field.name$)); res.append(buf);
$case uint16$char buf[20]; sprintf(buf,"%u",unsigned($var field.name$)); res.append(buf);
$case int32$char buf[20]; sprintf(buf,"%d",unsigned($var field.name$)); res.append(buf);
$case int64$char buf[30]; sprintf(buf,"%lld",static_cast<long long>($var field.name$)); res.append(buf);
$case bool$res.push_back($var field.name$ ? '1' : '0');
$-select$
        }
$-foreach$
        return res;
    }

$foreach field$
    bool has$var field.name:ucf$() const {
        return $var field.name$Flag;
    }
    $expand typeref field.type$ get$var field.name:ucf$() const {
$if options.throwOnUnsetGet$
        if (!$var field.name$Flag) {
            throw Exception( excType(), "$var message.name$ has no field $var field.name$");
        }
$-if$
        return $var field.name$;
    }
    void set$var field.name:ucf$( $expand typeref field.type$ v ) {
        this->$var field.name$Flag = true;
        this->$var field.name$ = v;
    }
$-foreach$

    template < class DataStream >
        void serialize( const $var protocol.name:ucf$& proto, DataStream& writer ) const
    {
        // printf( "serializing %s\n", toString().c_str() );
        checkFields();
        // mandatory fields
$foreach field$
$if field.mandatory$
        try {
            // printf( "write pos=%d field=%d\n", ds.getPos(), $var field.name$Tag );
            writer.writeTag($var field.name$Tag);
            $select field.type$
$case ascii$writer.writeAsciiLV($var field.name$);
$case utf8$writer.writeUTFLV($var field.name$);
$case byte$writer.writeByteLV($var field.name$);
$case uint16$writer.writeShortLV($var field.name$);
$case int32$writer.writeIntLV($var field.name$);
$case int64$writer.writeLongLV($var field.name$);
$case bool$writer.writeBoolLV($var field.name$);
$-select$
        } catch ( exceptions::IOException e ) {
            throw Exception( excType(), 
                             "writing field $var field.name$ in $var message.name$: %s",
                             e.what() );
        }
$-if$
$-foreach$
        // optional fields
$foreach field$
$if field.optional$
        if ( $var field.name$Flag ) {
            // printf( "write pos=%d field=%d\n", writer.getPos(), $var field.name$Tag );
            try {
                writer.writeTag($var field.name$Tag);
                $select field.type$
$case byte$writer.writeByteLV($var field.name$);
$case uint16$writer.writeShortLV($var field.name$);
$case int32$writer.writeIntLV($var field.name$);
$case int64$writer.writeLongLV($var field.name$);
$case ascii$writer.writeAsciiLV($var field.name$);
$case utf8$writer.writeUTFLV($var field.name$);
$case bool$writer.writeBoolLV($var field.name$);
$-select$
            } catch ( exceptions::IOException e ) {
                throw Exception( excType(),
                                 "writing field $var field.name$ in $var message.name$: %s",
                                 e.what() );
            }
        }
$-if$
$-foreach$
    }


    template <class DataStream>
    void deserialize( $var protocol.name:ucf$& proto, DataStream& reader )
    {
        clear();
        int tag = -1;
        try {
            do {
                // int pos = int(reader.getPos());
                tag = reader.readTag();
                // printf( "read pos=%d field=%d\n", pos, tag );
                if ( tag == -1 ) break;
                switch(tag) {
$foreach field$
                case $var field.name$Tag: {
                    if ($var field.name$Flag) {
                        throw Exception( excType(),
                                         "duplicate field $var field.name$ of $var message.name$" );
                    }
                    $select field.type$
$case byte$$var field.name$ = reader.readByteLV();
$case uint16$$var field.name$ = reader.readShortLV();
$case int32$$var field.name$ = reader.readIntLV();
$case int64$$var field.name$ = reader.readLongLV();
$case ascii$$var field.name$ = reader.readAsciiLV();
$case utf8$$var field.name$ = reader.readUTFLV();
$case bool$$var field.name$ = reader.readBoolLV();
$-select$
                    $var field.name$Flag = true;
                    break;
                }
$-foreach$
                default:
                    throw Exception( excType(),
                                     "$var message.name$ has invalid field:%u", tag );
                }
            } while ( true );
        } catch ( exceptions::IOException e ) {
            throw Exception( excType(),
                             "reading field tag=%u of $var message.name$: %s",
                             tag, e.what() );
        }
        // printf( "deserialized %s\n", toString().c_str() );
        checkFields();
    }

$if options.hasSeqNum$
    int32_t getSeqNum() const { return seqNum_; }
    void setSeqNum( int32_t seqnum ) { seqNum_ = seqnum; }
$-if$

protected:
    void checkFields() const
    {
$foreach field$
$if field.mandatory$
        if ( !$var field.name$Flag ) {
            throw Exception( excType(),
                             "message $var message.name$ does not have required field $var field.name$" );
        }
$-if$
$-foreach$        
    }

private:
    $var message.name$( const $var message.name$& );
    $var message.name$& operator = ( const $var message.name$& );

    inline bool isRequest() const {
        return $if message.isRequest$true$-if$$if !message.isRequest$false$-if$;
    }

    inline uint8_t excType() const {
        return isRequest() ? Status::BAD_REQUEST : Status::BAD_RESPONSE;
    }

protected:
$if options.hasSeqNum$
    int32_t seqNum_;
$-if$

$foreach field$
    $pack$
  $select field.type$
  $case byte$uint8_t
  $case uint16$uint16_t
  $case int32$int32_t
  $case int64$int64_t
  $case ascii$std::string
  $case utf8$std::string
  $case bool$bool
  $-select$
  $var field.name$$-pack$;
$-foreach$

$foreach field$
    bool $var field.name$Flag;
$-foreach$
};

$foreach namespace$
} // namespace $var namespace$
$-foreach$
#endif
