// NOTE: Do NOT edit this file (it is auto-generated).
// Instead, edit message-cpp.tmpl and regenerate.

#ifndef SCAG_BILL_EWALLET_STREAM_AUTHRESP_HPP
#define SCAG_BILL_EWALLET_STREAM_AUTHRESP_HPP

#include "util/int.h"
#include <string>
#include "scag/bill/ewallet/Status.h"
#include "scag/exc/IOException.h"
#include "scag/bill/ewallet/Exception.h"


namespace scag2 {
namespace bill {
namespace ewallet {
namespace stream {

class Protocol;

class AuthResp
{
protected:
    static const int statusValueTag = 1;
    static const int processingTimeoutTag = 13;

public:
    AuthResp()
    {
        statusValueFlag = false;
        processingTimeoutFlag = false;
    }

    ~AuthResp() {
    }

    void clear()
    {
        statusValueFlag=false;
        processingTimeoutFlag=false;
    }

    std::string toString() const
    {
        std::string res;
        res.reserve(200);
        res.append("AuthResp");
        {
            char buf[40];
            sprintf(buf," seq=%u",unsigned(getSeqNum()));
            res.append(buf);
        }
        if ( statusValueFlag ) {
            res.append(" statusValue=");
            char buf[10]; sprintf(buf,"%u",unsigned(statusValue)); res.append(buf);
        }
        if ( processingTimeoutFlag ) {
            res.append(" processingTimeout=");
            char buf[20]; sprintf(buf,"%d",unsigned(processingTimeout)); res.append(buf);
        }
        return res;
    }

    bool hasStatusValue() const {
        return statusValueFlag;
    }
    uint8_t getStatusValue() const {
        if (!statusValueFlag) {
            throw Exception( excType(), "AuthResp has no field statusValue");
        }
        return statusValue;
    }
    void setStatusValue( uint8_t v ) {
        this->statusValueFlag = true;
        this->statusValue = v;
    }
    bool hasProcessingTimeout() const {
        return processingTimeoutFlag;
    }
    int32_t getProcessingTimeout() const {
        if (!processingTimeoutFlag) {
            throw Exception( excType(), "AuthResp has no field processingTimeout");
        }
        return processingTimeout;
    }
    void setProcessingTimeout( int32_t v ) {
        this->processingTimeoutFlag = true;
        this->processingTimeout = v;
    }

    template < class DataStream >
        void serialize( const Protocol& proto, DataStream& writer ) const
    {
        printf( "serializing %s\n", toString().c_str() );
        checkFields();
        // mandatory fields
        try {
            // printf( "write pos=%d field=%d\n", ds.getPos(), statusValueTag );
            writer.writeTag(statusValueTag);
            writer.writeByteLV(statusValue);
        } catch ( exceptions::IOException e ) {
            throw Exception( excType(),
                             "writing field statusValue in AuthResp: %s",
                             e.what() );
        }
        try {
            // printf( "write pos=%d field=%d\n", ds.getPos(), processingTimeoutTag );
            writer.writeTag(processingTimeoutTag);
            writer.writeIntLV(processingTimeout);
        } catch ( exceptions::IOException e ) {
            throw Exception( excType(),
                             "writing field processingTimeout in AuthResp: %s",
                             e.what() );
        }
        // optional fields
    }


    template <class DataStream>
    void deserialize( Protocol& proto, DataStream& reader )
    {
        clear();
        int tag = -1;
        try {
            do {
                // int pos = int(reader.getPos());
                tag = reader.readTag();
                // printf( "read pos=%d field=%d\n", pos, tag );
                if ( tag == -1 ) break;
                switch(tag) {
                case statusValueTag: {
                    if (statusValueFlag) {
                        throw Exception( excType(),
                                         "duplicate field statusValue of AuthResp" );
                    }
                    statusValue = reader.readByteLV();
                    statusValueFlag = true;
                    break;
                }
                case processingTimeoutTag: {
                    if (processingTimeoutFlag) {
                        throw Exception( excType(),
                                         "duplicate field processingTimeout of AuthResp" );
                    }
                    processingTimeout = reader.readIntLV();
                    processingTimeoutFlag = true;
                    break;
                }
                default:
                    throw Exception( excType(),
                                     "AuthResp has invalid field:%u", tag );
                }
            } while ( true );
        } catch ( exceptions::IOException e ) {
            throw Exception( excType(),
                             "reading field tag=%u of AuthResp: %s",
                             tag, e.what() );
        }
        printf( "deserialized %s\n", toString().c_str() );
        checkFields();
    }

    int32_t getSeqNum() const { return seqNum_; }
    void setSeqNum( int32_t seqnum ) { seqNum_ = seqnum; }

protected:
    void checkFields() const
    {
        if ( !statusValueFlag ) {
            throw Exception( excType(),
                             "message AuthResp does not have required field statusValue" );
        }
        if ( !processingTimeoutFlag ) {
            throw Exception( excType(),
                             "message AuthResp does not have required field processingTimeout" );
        }
 
    }

private:
    AuthResp( const AuthResp& );
    AuthResp& operator = ( const AuthResp& );

    inline bool isRequest() const {
        return false;
    }

    inline uint8_t excType() const {
        return isRequest() ? Status::BAD_REQUEST : Status::BAD_RESPONSE;
    }

protected:
    int32_t seqNum_;

    uint8_t statusValue;
    int32_t processingTimeout;

    bool statusValueFlag;
    bool processingTimeoutFlag;
};

} // namespace scag2
} // namespace bill
} // namespace ewallet
} // namespace stream
#endif
