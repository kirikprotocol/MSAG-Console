// NOTE: Do NOT edit this file (it is auto-generated).
// Instead, edit message-cpp.tmpl and regenerate.

#ifndef SCAG_BILL_EWALLET_STREAM_OPEN_HPP
#define SCAG_BILL_EWALLET_STREAM_OPEN_HPP

#include "util/int.h"
#include <string>
#include "scag/bill/ewallet/Status.h"
#include "scag/exc/IOException.h"
#include "scag/bill/ewallet/Exception.h"


namespace scag2 {
namespace bill {
namespace ewallet {
namespace stream {

class Protocol;

class Open
{
protected:
    static const int agentIdTag = 6;
    static const int sourceIdTag = 14;
    static const int userIdTag = 7;
    static const int walletTypeTag = 8;
    static const int descriptionTag = 9;
    static const int amountTag = 10;
    static const int externalIdTag = 18;
    static const int timeoutTag = 11;

public:
    Open()
    {
        agentIdFlag = false;
        sourceIdFlag = false;
        userIdFlag = false;
        walletTypeFlag = false;
        descriptionFlag = false;
        amountFlag = false;
        externalIdFlag = false;
        timeoutFlag = false;
    }

    ~Open() {
    }

    void clear()
    {
        agentIdFlag=false;
        sourceIdFlag=false;
        userIdFlag=false;
        walletTypeFlag=false;
        descriptionFlag=false;
        amountFlag=false;
        externalIdFlag=false;
        timeoutFlag=false;
    }

    std::string toString() const
    {
        std::string res;
        res.reserve(200);
        res.append("Open");
        {
            char buf[40];
            sprintf(buf," seq=%u",unsigned(getSeqNum()));
            res.append(buf);
        }
        if ( agentIdFlag ) {
            res.append(" agentId=");
            char buf[20]; sprintf(buf,"%d",unsigned(agentId)); res.append(buf);
        }
        if ( sourceIdFlag ) {
            res.append(" sourceId=");
            res.push_back('"'); res.append(sourceId); res.push_back('"');
        }
        if ( userIdFlag ) {
            res.append(" userId=");
            res.push_back('"'); res.append(userId); res.push_back('"');
        }
        if ( walletTypeFlag ) {
            res.append(" walletType=");
            res.push_back('"'); res.append(walletType); res.push_back('"');
        }
        if ( descriptionFlag ) {
            res.append(" description=");
            res.push_back('"'); res.append(description); res.push_back('"');
        }
        if ( amountFlag ) {
            res.append(" amount=");
            char buf[20]; sprintf(buf,"%d",unsigned(amount)); res.append(buf);
        }
        if ( externalIdFlag ) {
            res.append(" externalId=");
            res.push_back('"'); res.append(externalId); res.push_back('"');
        }
        if ( timeoutFlag ) {
            res.append(" timeout=");
            char buf[20]; sprintf(buf,"%d",unsigned(timeout)); res.append(buf);
        }
        return res;
    }

    bool hasAgentId() const {
        return agentIdFlag;
    }
    int32_t getAgentId() const {
        if (!agentIdFlag) {
            throw Exception( excType(), "Open has no field agentId");
        }
        return agentId;
    }
    void setAgentId( int32_t v ) {
        this->agentIdFlag = true;
        this->agentId = v;
    }
    bool hasSourceId() const {
        return sourceIdFlag;
    }
    const std::string& getSourceId() const {
        if (!sourceIdFlag) {
            throw Exception( excType(), "Open has no field sourceId");
        }
        return sourceId;
    }
    void setSourceId( const std::string& v ) {
        this->sourceIdFlag = true;
        this->sourceId = v;
    }
    bool hasUserId() const {
        return userIdFlag;
    }
    const std::string& getUserId() const {
        if (!userIdFlag) {
            throw Exception( excType(), "Open has no field userId");
        }
        return userId;
    }
    void setUserId( const std::string& v ) {
        this->userIdFlag = true;
        this->userId = v;
    }
    bool hasWalletType() const {
        return walletTypeFlag;
    }
    const std::string& getWalletType() const {
        if (!walletTypeFlag) {
            throw Exception( excType(), "Open has no field walletType");
        }
        return walletType;
    }
    void setWalletType( const std::string& v ) {
        this->walletTypeFlag = true;
        this->walletType = v;
    }
    bool hasDescription() const {
        return descriptionFlag;
    }
    const std::string& getDescription() const {
        if (!descriptionFlag) {
            throw Exception( excType(), "Open has no field description");
        }
        return description;
    }
    void setDescription( const std::string& v ) {
        this->descriptionFlag = true;
        this->description = v;
    }
    bool hasAmount() const {
        return amountFlag;
    }
    int32_t getAmount() const {
        if (!amountFlag) {
            throw Exception( excType(), "Open has no field amount");
        }
        return amount;
    }
    void setAmount( int32_t v ) {
        this->amountFlag = true;
        this->amount = v;
    }
    bool hasExternalId() const {
        return externalIdFlag;
    }
    const std::string& getExternalId() const {
        if (!externalIdFlag) {
            throw Exception( excType(), "Open has no field externalId");
        }
        return externalId;
    }
    void setExternalId( const std::string& v ) {
        this->externalIdFlag = true;
        this->externalId = v;
    }
    bool hasTimeout() const {
        return timeoutFlag;
    }
    int32_t getTimeout() const {
        if (!timeoutFlag) {
            throw Exception( excType(), "Open has no field timeout");
        }
        return timeout;
    }
    void setTimeout( int32_t v ) {
        this->timeoutFlag = true;
        this->timeout = v;
    }

    template < class DataStream >
        void serialize( const Protocol& proto, DataStream& writer ) const
    {
        // printf( "serializing %s\n", toString().c_str() );
        checkFields();
        // mandatory fields
        try {
            // printf( "write pos=%d field=%d\n", ds.getPos(), agentIdTag );
            writer.writeTag(agentIdTag);
            writer.writeIntLV(agentId);
        } catch ( exceptions::IOException e ) {
            throw Exception( excType(),
                             "writing field agentId in Open: %s",
                             e.what() );
        }
        try {
            // printf( "write pos=%d field=%d\n", ds.getPos(), userIdTag );
            writer.writeTag(userIdTag);
            writer.writeAsciiLV(userId);
        } catch ( exceptions::IOException e ) {
            throw Exception( excType(),
                             "writing field userId in Open: %s",
                             e.what() );
        }
        try {
            // printf( "write pos=%d field=%d\n", ds.getPos(), walletTypeTag );
            writer.writeTag(walletTypeTag);
            writer.writeAsciiLV(walletType);
        } catch ( exceptions::IOException e ) {
            throw Exception( excType(),
                             "writing field walletType in Open: %s",
                             e.what() );
        }
        try {
            // printf( "write pos=%d field=%d\n", ds.getPos(), descriptionTag );
            writer.writeTag(descriptionTag);
            writer.writeAsciiLV(description);
        } catch ( exceptions::IOException e ) {
            throw Exception( excType(),
                             "writing field description in Open: %s",
                             e.what() );
        }
        try {
            // printf( "write pos=%d field=%d\n", ds.getPos(), amountTag );
            writer.writeTag(amountTag);
            writer.writeIntLV(amount);
        } catch ( exceptions::IOException e ) {
            throw Exception( excType(),
                             "writing field amount in Open: %s",
                             e.what() );
        }
        try {
            // printf( "write pos=%d field=%d\n", ds.getPos(), timeoutTag );
            writer.writeTag(timeoutTag);
            writer.writeIntLV(timeout);
        } catch ( exceptions::IOException e ) {
            throw Exception( excType(),
                             "writing field timeout in Open: %s",
                             e.what() );
        }
        // optional fields
        if ( sourceIdFlag ) {
            // printf( "write pos=%d field=%d\n", writer.getPos(), sourceIdTag );
            try {
                writer.writeTag(sourceIdTag);
                writer.writeAsciiLV(sourceId);
            } catch ( exceptions::IOException e ) {
                throw Exception( excType(),
                                 "writing field sourceId in Open: %s",
                                 e.what() );
            }
        }
        if ( externalIdFlag ) {
            // printf( "write pos=%d field=%d\n", writer.getPos(), externalIdTag );
            try {
                writer.writeTag(externalIdTag);
                writer.writeAsciiLV(externalId);
            } catch ( exceptions::IOException e ) {
                throw Exception( excType(),
                                 "writing field externalId in Open: %s",
                                 e.what() );
            }
        }
    }


    template <class DataStream>
    void deserialize( Protocol& proto, DataStream& reader )
    {
        clear();
        int tag = -1;
        try {
            do {
                // int pos = int(reader.getPos());
                tag = reader.readTag();
                // printf( "read pos=%d field=%d\n", pos, tag );
                if ( tag == -1 ) break;
                switch(tag) {
                case agentIdTag: {
                    if (agentIdFlag) {
                        throw Exception( excType(),
                                         "duplicate field agentId of Open" );
                    }
                    agentId = reader.readIntLV();
                    agentIdFlag = true;
                    break;
                }
                case sourceIdTag: {
                    if (sourceIdFlag) {
                        throw Exception( excType(),
                                         "duplicate field sourceId of Open" );
                    }
                    sourceId = reader.readAsciiLV();
                    sourceIdFlag = true;
                    break;
                }
                case userIdTag: {
                    if (userIdFlag) {
                        throw Exception( excType(),
                                         "duplicate field userId of Open" );
                    }
                    userId = reader.readAsciiLV();
                    userIdFlag = true;
                    break;
                }
                case walletTypeTag: {
                    if (walletTypeFlag) {
                        throw Exception( excType(),
                                         "duplicate field walletType of Open" );
                    }
                    walletType = reader.readAsciiLV();
                    walletTypeFlag = true;
                    break;
                }
                case descriptionTag: {
                    if (descriptionFlag) {
                        throw Exception( excType(),
                                         "duplicate field description of Open" );
                    }
                    description = reader.readAsciiLV();
                    descriptionFlag = true;
                    break;
                }
                case amountTag: {
                    if (amountFlag) {
                        throw Exception( excType(),
                                         "duplicate field amount of Open" );
                    }
                    amount = reader.readIntLV();
                    amountFlag = true;
                    break;
                }
                case externalIdTag: {
                    if (externalIdFlag) {
                        throw Exception( excType(),
                                         "duplicate field externalId of Open" );
                    }
                    externalId = reader.readAsciiLV();
                    externalIdFlag = true;
                    break;
                }
                case timeoutTag: {
                    if (timeoutFlag) {
                        throw Exception( excType(),
                                         "duplicate field timeout of Open" );
                    }
                    timeout = reader.readIntLV();
                    timeoutFlag = true;
                    break;
                }
                default:
                    throw Exception( excType(),
                                     "Open has invalid field:%u", tag );
                }
            } while ( true );
        } catch ( exceptions::IOException e ) {
            throw Exception( excType(),
                             "reading field tag=%u of Open: %s",
                             tag, e.what() );
        }
        printf( "deserialized %s\n", toString().c_str() );
        checkFields();
    }

    int32_t getSeqNum() const { return seqNum_; }
    void setSeqNum( int32_t seqnum ) { seqNum_ = seqnum; }

protected:
    void checkFields() const
    {
        if ( !agentIdFlag ) {
            throw Exception( excType(),
                             "message Open does not have required field agentId" );
        }
        if ( !userIdFlag ) {
            throw Exception( excType(),
                             "message Open does not have required field userId" );
        }
        if ( !walletTypeFlag ) {
            throw Exception( excType(),
                             "message Open does not have required field walletType" );
        }
        if ( !descriptionFlag ) {
            throw Exception( excType(),
                             "message Open does not have required field description" );
        }
        if ( !amountFlag ) {
            throw Exception( excType(),
                             "message Open does not have required field amount" );
        }
        if ( !timeoutFlag ) {
            throw Exception( excType(),
                             "message Open does not have required field timeout" );
        }
 
    }

private:
    Open( const Open& );
    Open& operator = ( const Open& );

    inline bool isRequest() const {
        return true;
    }

    inline uint8_t excType() const {
        return isRequest() ? Status::BAD_REQUEST : Status::BAD_RESPONSE;
    }

protected:
    int32_t seqNum_;

    int32_t agentId;
    std::string sourceId;
    std::string userId;
    std::string walletType;
    std::string description;
    int32_t amount;
    std::string externalId;
    int32_t timeout;

    bool agentIdFlag;
    bool sourceIdFlag;
    bool userIdFlag;
    bool walletTypeFlag;
    bool descriptionFlag;
    bool amountFlag;
    bool externalIdFlag;
    bool timeoutFlag;
};

} // namespace scag2
} // namespace bill
} // namespace ewallet
} // namespace stream
#endif
