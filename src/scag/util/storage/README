NOTE: this package is for generic template storage classes.
So, please do not place here your code dependent on packages other than:
util
logger
core/*


=== directory:
 1. Хранилище сессий. Описание, тесты.
 2. Формат заголовков блоков в файле данных хранилища BlocksHSStorage3.
 3. Формат файла индексов персонализации.


                       1. Хранилище сессий.
                       ===================

1. Устройство хранилища.

Хранилище сессий (или других обьектов)
(CachedDiskStorage<MemStorage, DiskStorage, Allocator=HeapAllocator>)
представляет собой обьединение кэша (шаблонный параметр MemStorage),
и дискового хранилища данный (шаблонный параметр DiskStorage).

Доступ к обьектам в хранилище осуществляется только по ключу,
хотя есть возможность последовательного прохождения по всем 
обьектам хранилища (iterator).

Хранилище предоставляет основные операции, такие как
добавление обьекта, поиск обьекта, сброс обьекта на диск,
удаление обьекта из хранилища (с возможностью также удаления с диска),
а также получение итератора на хранилище.

Для выполнения этих операций хранилище вызывает определенные методы
шаблонных параметров MemStorage, DiskStorage, и Allocator, которые должны
поддерживать требуемый интерфейс.

Шаблонный параметр - класс MemStorage (пока существует единственная имплементация 
HashedMemoryCache<Key,Val,TypeJuggling,HF>)
предоставляет методы для добавления, поиска, удаления, итерирования по
обьектам в памяти.  Доступ осуществляется по ключу типа Key.

Необходимо отметить, что тип хранимого в памяти (MemStorage::stored_type)
обьекта может отличаться от типа, видимого клиентом (MemStorage::value_type).
Для приведения типов используется класс-политика TypeJuggling.
В этой политике должны быть определены typedef'ы хранимого и видимого типов,
а также методы для их преобразования друг в друга.
По умолчанию шаблонный параметр TypeJuggling определен как
MemoryCacheSimpleTypeJuggling< Val >, где оба типа
определяются одинаково (Val*).

Кэшированные обьекты хранятся в хэше, за вычисление хэш функции
отвечает четвертый параметр шаблона -- HF, который просто передается
в XHash.

Дисковое хранилище (шаблонный параметр DiskStorage) должно предоставлять
методы для сохранения, подкачки и удаления обьекта.
Доступ к обьектам в хранилище осуществляется по ключу.

Одна из реализаций дискового хранилища -- IndexedStorage< IStorage, DStorage >.
Этот класс параметризуется двумя шаблонными параметрами -- 
типом дискового хранилищ индексов к данным (IStorage) и
типом дискового хранилища сериализованных данных (DStorage).
Такой выбор организации хранилища определяется
тем, что сериализованные данные хранятся последовательно в файлах большого
размера, а положение сериализованного обьекта в файле обычно задается
целым числом -- смещением от начала файла или индексом блока в файле.

Шаблонный параметр IStorage определяет дисковое хранилище
индексов к сериализованным данным и предоставляет методы
для добавления, удаления, поиска индекса по ключу и итерирования по индексам.
Единственная существующая сейчас реализация --
RBTreeIndexedStorage< Key, Idx > использует для хранения RB-деревья.

Шаблонный параметр DStorage -- дисковое хранилище сериализованных
данных.  Доступ к дисковым 
данным осуществляется по индексу, обычно это целое число -- либо смещение
от начала файла, либо индекс блока в файле.
Предполагается, что хранилище имеет внутренний изменяемый (mutable) 
буфер, и весь поток данных с/на диск идет через него.
Таким образом, DStorage должен предоставлять методы для сериализации обьекта в буфер,
добавления содержимого буфера на диск, чтения с диска в буфер, десериализации
обьекта из буфера, удаления обьекта с диска.

В настоящий момент существует две реализации дискового хранилища данных:
PageFileDiskStorage< Key, Val, PF > и BHDiskStorage< Key, Val >.
Хранение данных в них осуществляется в core/buffers/PageFile и
в BlocksHSStorage, соответственно.

Кроме того, существует еще одна из реализаций дискового хранилища --
CompositeDiskStorage< DStorage >.  Это составное хранилище,
состоящее из нескольких (элементарных) хранилищ типа DStorage.

Каждому элементарному хранилищу DStorage присвоен порядковый номер.
Перед выполнением любой из операций, по переданному ключу находится номер
элементарного хранилища, с которым необходимо выполнить данную операцию.
Для вычисления номера элементарного хранилища используется
метод storage() из класса StorageNumbering.  Кроме того,
требуется чтобы у ключа существовал метод toIndex(), возвращающий целое число.

Резюмируя, можно выделить 4 типа (2x2) хранилища, с которыми проводились тесты:
- на основе PageFile (далее pgf) или на основе BlocksHSStorage (далее bhs);
- единичное (далее single) или составное, т.е. обернутое в CompositeDiskStorage (далее composite).


2. Организация тестов.

Проведение тестов выполнялось одной программой testrb, скомпилированной
для четырех возможных типов хранилища.

В начале тестовой программы, после создания/открытия хранилищ,
выполняется проверка существующей структуры дисковых хранилищ 
(если они были созданы в предыдущих запусках программы).
Для этого вычитываются все данные из хранилища, т.е. проверяется,
что хранилище не "битое", а также проверяется совпадение 
ключа, использованного для индексирования данного, с прочитанным
из сериализованного данного.  В случае каких-либо проблем
программа завершается с ненулевым кодом возврата.

Затем выполняется заданного количество проходов основного цикла,
который выглядел одинаково для всех типов
дискового хранилища.  В каждом проходе цикла:
 - случайным образом генерировался ключ обьекта (номер абонента) 
   в интервале 89130000000..89131000000;
 - по сгенерированному ключу выполнялся поиск обьекта в кэше;
 - если обьект в кэше отсутствовал, то выполнялся поиск и подкачка обьекта
   с диска;
 - если обьект отсутствовал на диске, то в кэш добавлялся новый обьект
   с данным ключом (не сбрасывая обьект на диск);
 - с вероятностью 3% выполнялись следующие действия:
   - все накопленные к данному моменту обьекты из кэша сбрасывались на диск;
   - с вероятностью 0.3% все накопленные в кэше обьекты очищались с диска;
   - кэш очищался.

В конце работы подводится статистика: печатается кол-во
hit/miss, добавленных/удаленных обьектов, и кол-во обьектов в хранилище.


3. Тесты на утечки памяти.

Проводились с помощью программы valgrind.  В последней версии утечек не обнаружено.


4. Тесты на стабильность дискового хранилища.

Для этого, сразу перед началом основного цикла тестов, в программе
запускается еще один поток исполнения, который ожидает несколько
секунд, а затем убивает основное приложения сигналом KILL.

В шелле проверяется код возврата приложения, если он соответствует
SIGKILL, то программа перезапускается.

Если же код возврата иной, т.е. вероятно программа завершилась из-за exception
или при обраружении "битого" хранилища, то перезапуск не происходит.

После исправления некоторых ошибок все тесты успешно пережили 1000 перезапусков
на bukind (i386-linux) и phoenix (sparc-sunos).


5. Тесты на "скорострельность".

Скорость работы определялась программой time на слабо загруженной машине bukind.

Параметры тестов:
 - indexgrowth = 1000 -- прирост индексов при росте дерева индексов;
 - cachesize = 1000 -- начальный размер кэша;
 - pagesize = 256 -- размер страницы в PageFile 
                   и блока (за вычетом заголовка) в BlocksHSStorage;
 - preallocate = 100000 -- начальный размер PageFile (в страницах)
                   и размер файла в BlocksHSStorage (в блоках);
 - interval = 1000000 - интервал номеров абонентов;
 - objectsize = 1481 - размер сериализованного обьекта.
 - кол-во элементарных хранилищ на одно композитное -- 20.

5.1. Время создания хранилища.
                  real    user   sys
bhs-single        0.47    0.03   0.41
bhs-composite    15.9     0.5    7.9
pgf-single        0.49    0.29   0.13
pgf-composite    14.3     5.6    2.4

5.2. Заполнение пустого хранилища 10000 обьектами.
 вставок=10000, удалений~=1000, конечный размер=9000.

                  real    user   sys
bhs-single        2.79    1.37   1.06
bhs-composite     3.19    1.44   1.0
pgf-single        3.62    1.15   1.63
pgf-composite     3.13    1.24   1.70

5.3. Дозаполнение хранилища еще 100000 обьектами.
 хитов=28000, вставок=72000, удалений~=10000, конечный размер=71000

                  real    user   sys
bhs-single       66.1    15.7   13.4
bhs-composite    98.3    16.9   11.7
pgf-single       81.9    14.3   17.3
pgf-composite    63.6    14.0   20.5

5.4. Работа с наполненным хранилищем (доступ к 10000 обьектам).
  хитов~=9100, вставок~=850, удалений~=700
                  real    user   sys
bhs-single       11.7     1.95   1.33
bhs-composite     3.4     2.0    1.3
pgf-single       15.6     1.6    2.5
pgf-composite    23.8     1.7    2.9

5.5. Общие выводы

Время работы с хранилищами приблизительно одинаково (смотрим на user+sys),
некоторый выигрыш имеется у bhs хранилища (3.3 секунды вместо 4.5).
Композитное хранилище (субьективно) слегка медленнее одиночного.




              2. Формат заголовков блоков в файле данных хранилища BlocksHSStorage3.
              =====================================================================

Блок может быть в одном из трех состояний: free, head, used(not head).
Полный размер блока (включая заголовок) указывается при создании хранилища.
Собственно заголовок занимает первые 16 байт блока.

Положение блока в хранилище характеризуется абсолютным смещением (offset) блока.
Ссылки на другие блоки в заголовке блока записываются в виде поля
длиной 56 бит, однако старший бит в этом поле является признаком того, что ссылка
не используется.  Таким образом остается 55 значащих бит, что соответствует
максимальному размеру хранилища в 32768 терабайт.

Поля блока записываются на диск в сетевом формате (старшие биты раньше).
Ниже представлено побитовое содержимое двух 64-битных слов заголовка блока
для трех возможных состояний блока (free,head,used):

  номера        6666555555555544444444443333333333222222222211111111110000000000
  битов         3210987654321098765432109876543210987654321098765432109876543210

free-0          0xxxxxx0nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn
free-1          xxxxxxxxffffffffffffffffffffffffffffffffffffffffffffffffffffffff   

head-0          1xxxxxx1nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn
head-1          ppppppppdddddddddddddddddddddddddddddddddddddddddddddddddddddddd

used-0          1xxxxxx0nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn
used-1          xxxxxxxxhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh

Пояснения:
 0/1   -- биты, установленные в 0/1 соответственно;
 x     -- зарезервированные биты;
 nnn   -- ссылка на следующий блок в цепи;
 fff   -- количество свободных блоков, следующих за данным;
 ddd   -- размер данных в цепи в байтах, включая размер заголовков;
 hhh   -- ссылка на начальный блок цепи.



                  3. Формат файла индексов абонентов в персонализации
                  ===================================================

Это файл с именем вида abonent-index.

смещ длина описание поля
0    0x14  заголовок - признак индексного файла
0x14 0x04  версия файла (должна быть 2 для новых файлов)
0x18 0x04  полное кол-во узлов
0x1c 0x04  кол-во занятых узлов
0x20 0x04  кол-во свободных узлов
0x24 0x04  _индекс корневого узла_
0x28 0x04  индекс первого свободного узла
0x2c 0x04  индекс нулевого узла
0x30 0x04  сколько узлов выделять при необходимости расширения дерева
0x34 ----  все до 0xd4 -- резервированное место
0xd4+i*S  S  узел дерева с индексом i
здесь S -- размер узла дерева, для абонентов он равен 0x20.

Содержимое узла:
0x00 0x04  индекс родительского узла (или 0)
0x04 0x04  индекс левой ветки (или 0)
0x08 0x04  индекс правой ветки (или 0)
0x0c 0x01  цвет узла (0 - черный, 1 - красный)
0x0d 0x0b  закодированный номер абонента
0x18 0x08  смещение на данные профиля абонента в файле данных

Кодирование номера абонента вида .ton.npi.value
0x00 0x01  реальная длина value -- len
0x01 0x01  ton
0x02 0x01  npi
0x03 0x08  закодированное value, используется только первые (len+1)/2 байт,
  остальное дописывается значением 0xff.

Кодирование value устроено таким образом, чтобы при просмотре шестнадцатеричного
дампа были видны ключи.  К сожалению, в первой версии кодирования была допущена
ошибка с порядком цифр, она была исправлена в новой версии.  Признак версии
определяется значением последнего полубайта в value, если он 0xе, то версия новая,
иначе старая.  Таким образом, длинные номера (len>14) нельзя закодировать в новой версии,
так как они используют этот полубайт.

Пример кодирования некоторых адресов:
                     len ton npi  value
<пустой>             00  00  00  ff ff ff ff ff ff ff fe
.1.1.79137654079     0b  01  01  79 13 76 54 07 9f ff fe  <-- новая версия
.1.1.79137654079     0b  01  01  97 31 67 45 70 f9 ff ff  <-- старая версия


                4. Формат файла индексов сервисов в персонализации
                ==================================================

Это файл с именем вида service.idx (operator.idx,provider.idx).

смещ длина описание поля
0    0x04 заголовок -- признак диск-хэш файла
0x04 0x04 версия (должна быть 0x00010000)
0x08 0x04 кол-во использованных элементов
0x0c 0x04 размер хэша - полное кол-во элементов
0x10 0x04 флаги
0x14 0x04 контрольная сумма заголовка
0x18+i*S S элемент хэша с индексом i
здесь S -- размер элемента, S=0x12

Содержимое элемента:
0x00 0x02 флаг (0-пустой, 1-используется, 2-удален)
0x02 0x04 хэш-код
0x06 0x04 ключ - номер сервиса/оператора/провайдера
0x0a 0x08 значение - смещение в файле с данными
