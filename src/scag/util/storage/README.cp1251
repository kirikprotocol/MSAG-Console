NOTE: this package is for generic template storage classes.
So, please do not place here your code dependent on packages other than:
util
logger
core/*


1. Устройство хранилища.

Хранилище сессий (или других обьектов)
(CachedDiskStorage<MemStorage, DiskStorage, Allocator=HeapAllocator>)
представляет собой обьединение кэша (шаблонный параметр MemStorage),
и дискового хранилища данный (шаблонный параметр DiskStorage).

Доступ к обьектам в хранилище осуществляется только по ключу,
хотя есть возможность последовательного прохождения по всем 
обьектам хранилища (iterator).

Хранилище предоставляет основные операции, такие как
добавление обьекта, поиск обьекта, сброс обьекта на диск,
удаление обьекта из хранилища (с возможностью также удаления с диска),
а также получение итератора на хранилище.

Для выполнения этих операций хранилище вызывает определенные методы
шаблонных параметров MemStorage, DiskStorage, и Allocator, которые должны
поддерживать требуемый интерфейс.

Шаблонный параметр - класс MemStorage (пока существует единственная имплементация 
HashedMemoryCache<Key,Val,TypeJuggling,HF>)
предоставляет методы для добавления, поиска, удаления, итерирования по
обьектам в памяти.  Доступ осуществляется по ключу типа Key.

Необходимо отметить, что тип хранимого в памяти (MemStorage::stored_type)
обьекта может отличаться от типа, видимого клиентом (MemStorage::value_type).
Для приведения типов используется класс-политика TypeJuggling.
В этой политике должны быть определены typedef'ы хранимого и видимого типов,
а также методы для их преобразования друг в друга.
По умолчанию шаблонный параметр TypeJuggling определен как
MemoryCacheSimpleTypeJuggling< Val >, где оба типа
определяются одинаково (Val*).

Кэшированные обьекты хранятся в хэше, за вычисление хэш функции
отвечает четвертый параметр шаблона -- HF, который просто передается
в XHash.

Дисковое хранилище (шаблонный параметр DiskStorage) должно предоставлять
методы для сохранения, подкачки и удаления обьекта.
Доступ к обьектам в хранилище осуществляется по ключу.

Одна из реализаций дискового хранилища -- IndexedStorage< IStorage, DStorage >.
Этот класс параметризуется двумя шаблонными параметрами -- 
типом дискового хранилищ индексов к данным (IStorage) и
типом дискового хранилища сериализованных данных (DStorage).
Такой выбор организации хранилища определяется
тем, что сериализованные данные хранятся последовательно в файлах большого
размера, а положение сериализованного обьекта в файле обычно задается
целым числом -- смещением от начала файла или индексом блока в файле.

Шаблонный параметр IStorage определяет дисковое хранилище
индексов к сериализованным данным и предоставляет методы
для добавления, удаления, поиска индекса по ключу и итерирования по индексам.
Единственная существующая сейчас реализация --
RBTreeIndexedStorage< Key, Idx > использует для хранения RB-деревья.

Шаблонный параметр DStorage -- дисковое хранилище сериализованных
данных.  Доступ к дисковым 
данным осуществляется по индексу, обычно это целое число -- либо смещение
от начала файла, либо индекс блока в файле.
Предполагается, что хранилище имеет внутренний изменяемый (mutable) 
буфер, и весь поток данных с/на диск идет через него.
Таким образом, DStorage должен предоставлять методы для сериализации обьекта в буфер,
добавления содержимого буфера на диск, чтения с диска в буфер, десериализации
обьекта из буфера, удаления обьекта с диска.

В настоящий момент существует две реализации дискового хранилища данных:
PageFileDiskStorage< Key, Val, PF > и BHDiskStorage< Key, Val >.
Хранение данных в них осуществляется в core/buffers/PageFile и
в BlocksHSStorage, соответственно.

Кроме того, существует еще одна из реализаций дискового хранилища --
CompositeDiskStorage< DStorage >.  Это составное хранилище,
состоящее из нескольких (элементарных) хранилищ типа DStorage.

Каждому элементарному хранилищу DStorage присвоен порядковый номер.
Перед выполнением любой из операций, по переданному ключу находится номер
элементарного хранилища, с которым необходимо выполнить данную операцию.
Для вычисления номера элементарного хранилища используется
метод storage() из класса StorageNumbering.  Кроме того,
требуется чтобы у ключа существовал метод toIndex(), возвращающий целое число.

Резюмируя, можно выделить 4 типа (2x2) хранилища, с которыми проводились тесты:
- на основе PageFile (далее pgf) или на основе BlocksHSStorage (далее bhs);
- единичное (далее single) или составное, т.е. обернутое в CompositeDiskStorage (далее composite).


2. Организация тестов.

Проведение тестов выполнялось одной программой testrb, скомпилированной
для четырех возможных типов хранилища.

В начале тестовой программы, после создания/открытия хранилищ,
выполняется проверка существующей структуры дисковых хранилищ 
(если они были созданы в предыдущих запусках программы).
Для этого вычитываются все данные из хранилища, т.е. проверяется,
что хранилище не "битое", а также проверяется совпадение 
ключа, использованного для индексирования данного, с прочитанным
из сериализованного данного.  В случае каких-либо проблем
программа завершается с ненулевым кодом возврата.

Затем выполняется заданного количество проходов основного цикла,
который выглядел одинаково для всех типов
дискового хранилища.  В каждом проходе цикла:
 - случайным образом генерировался ключ обьекта (номер абонента) 
   в интервале 89130000000..89131000000;
 - по сгенерированному ключу выполнялся поиск обьекта в кэше;
 - если обьект в кэше отсутствовал, то выполнялся поиск и подкачка обьекта
   с диска;
 - если обьект отсутствовал на диске, то в кэш добавлялся новый обьект
   с данным ключом (не сбрасывая обьект на диск);
 - с вероятностью 3% выполнялись следующие действия:
   - все накопленные к данному моменту обьекты из кэша сбрасывались на диск;
   - с вероятностью 0.3% все накопленные в кэше обьекты очищались с диска;
   - кэш очищался.

В конце работы подводится статистика: печатается кол-во
hit/miss, добавленных/удаленных обьектов, и кол-во обьектов в хранилище.


3. Тесты на утечки памяти.

Проводились с помощью программы valgrind.  В последней версии утечек не обнаружено.


4. Тесты на стабильность дискового хранилища.

Для этого, сразу перед началом основного цикла тестов, в программе
запускается еще один поток исполнения, который ожидает несколько
секунд, а затем убивает основное приложения сигналом KILL.

В шелле проверяется код возврата приложения, если он соответствует
SIGKILL, то программа перезапускается.

Если же код возврата иной, т.е. вероятно программа завершилась из-за exception
или при обраружении "битого" хранилища, то перезапуск не происходит.

После исправления некоторых ошибок все тесты успешно пережили 1000 перезапусков
на bukind (i386-linux) и phoenix (sparc-sunos).


5. Тесты на "скорострельность".

Скорость работы определялась программой time на слабо загруженной машине bukind.

Параметры тестов:
 - indexgrowth = 1000 -- прирост индексов при росте дерева индексов;
 - cachesize = 1000 -- начальный размер кэша;
 - pagesize = 256 -- размер страницы в PageFile 
                   и блока (за вычетом заголовка) в BlocksHSStorage;
 - preallocate = 100000 -- начальный размер PageFile (в страницах)
                   и размер файла в BlocksHSStorage (в блоках);
 - interval = 1000000 - интервал номеров абонентов;
 - objectsize = 1481 - размер сериализованного обьекта.
 - кол-во элементарных хранилищ на одно композитное -- 20.

5.1. Время создания хранилища.
                  real    user   sys
bhs-single        0.47    0.03   0.41
bhs-composite    15.9     0.5    7.9
pgf-single        0.49    0.29   0.13
pgf-composite    14.3     5.6    2.4

5.2. Заполнение пустого хранилища 10000 обьектами.
 вставок=10000, удалений~=1000, конечный размер=9000.

                  real    user   sys
bhs-single        2.79    1.37   1.06
bhs-composite     3.19    1.44   1.0
pgf-single        3.62    1.15   1.63
pgf-composite     3.13    1.24   1.70

5.3. Дозаполнение хранилища еще 100000 обьектами.
 хитов=28000, вставок=72000, удалений~=10000, конечный размер=71000

                  real    user   sys
bhs-single       66.1    15.7   13.4
bhs-composite    98.3    16.9   11.7
pgf-single       81.9    14.3   17.3
pgf-composite    63.6    14.0   20.5

5.4. Работа с наполненным хранилищем (доступ к 10000 обьектам).
  хитов~=9100, вставок~=850, удалений~=700
                  real    user   sys
bhs-single       11.7     1.95   1.33
bhs-composite     3.4     2.0    1.3
pgf-single       15.6     1.6    2.5
pgf-composite    23.8     1.7    2.9

5.5. Общие выводы

Время работы с хранилищами приблизительно одинаково (смотрим на user+sys),
некоторый выигрыш имеется у bhs хранилища (3.3 секунды вместо 4.5).
Композитное хранилище (субьективно) слегка медленнее одиночного.
