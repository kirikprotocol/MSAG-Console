#include <unistd.h>
#include <fcntl.h>

#include "scag/advert/Advertising.h"
#include "scag/adverTest/AdvertCount.h"     // счетчик
#include "scag/adverTest/AdvertParams.h"    // параметры

#include "scag/util/encodings/Encodings.h"
#include "core/synchronization/Event.hpp"

// типы кодировок
enum 
{
	UTF16BE = 1,
	GSMSMS,
	GSMUSSD
};

//  режимы работ
enum 
{
	SYNC_MODE_0,		// синхронный, без BannnerRequest
	SYNC_MODE_1,		// синхронный, использу€ BannnerRequest
	ASYNC_MODE,			// асинхронный
	RANDOM_MODE			// "случайна€" смесь
};


using namespace scag::advert;
using namespace scag::util::encodings;
using namespace std;

AdvertParams Params;                                      


//------------------------------------------------------------------------------
// 
class AsyncsCounter
{
    IntHash <BannerRequest*> AsyncRequests; // список указателей  асинхронных запросов
    Mutex AsyncRequestsMutex;
    Event pause;

    public:    
    void Add(BannerRequest* br)
    {
        pause.Wait(1);   // просто жестка€ задержка дл€ всех
        
        MutexGuard mg(AsyncRequestsMutex);
        AsyncRequests.Insert(br->getId(), br);           
    }

    void Delete(BannerRequest* br)
    {
        MutexGuard mg(AsyncRequestsMutex);
        if (AsyncRequests.Exist( br->getId()))
            AsyncRequests.Delete(br->getId());
    }
   
/*    void PrintCount()
    {
        MutexGuard mg(AsyncRequestsMutex);
        printf("AsyncRequests.Count = %d\n", AsyncRequests.Count());    
    }	 
    ~AsyncsCounter() {  AsyncRequests.Empty(); }
  */  
    
} AsyncsCountGuard;

//------------------------------------------------------------------------------
// 
class AdvertRun : public Thread
{
//------------------------------------------------------------------------------
// 
struct TestBannerDispatcher: BannerDispatcher 
{
    AdvertRun* adv;
    // On banner received
    void processBanner(const BannerRequest& req) 
    {
        if (adv)
            adv->AnalizeRezult(req, 0);        
    }

    // On error occurred
    void processError(const BannerRequest& req, uint32_t status)
    {
        if (adv) 
            adv->AnalizeRezult(req, status);
    } 
    
    //TestBannerDispatcher(AdvertRun* advRun) { adv = advRun; }
    TestBannerDispatcher() { adv = NULL; }
};  			                

    counter* Counter;           // cчетчик
    Advertising* Advert;        // экземпл€р реализации Advrtise
    int runMode;				// режим выполнени€
    TestBannerDispatcher dispatch;
    
    protected:
	int Execute()
	{
            if (!Advert)
            {
                puts("не определена реализаци€ Advert!");
                return 1;
            }
            while(stop == false)    
            {
            	int abnt_indx, rc;
            	string banner;
                                
                int curmode = runMode;
            	if (curmode < 0 || curmode >= RANDOM_MODE)
            		curmode =  Counter->all % RANDOM_MODE;
                
                switch(curmode)
            	{ 
            		case SYNC_MODE_0:
            			{
			                rc= Advert->getBanner(  Params.GetAbonent(abnt_indx),
			                                        Params.GetService(),  
			                                        Params.GetTransportType(),
			                                        UTF16BE, banner);
			    
			                BannerRequest tmpBR("", "", 0, 0); 
			                tmpBR.banner = banner;
			                AnalizeRezult(tmpBR, rc);
			                break;
            			}   
            		case SYNC_MODE_1:
            			{
			                BannerRequest tmpBR(Params.GetAbonent(abnt_indx),
                                                Params.GetService(),
			                					Params.GetTransportType(), UTF16BE); 
			                
			                rc= Advert->getBanner(tmpBR);
			                AnalizeRezult(tmpBR, rc);
			                break;
            			}   
            		case  ASYNC_MODE:
            			{
                            BannerRequest* tmpBR = new  BannerRequest
                                                       (Params.GetAbonent(abnt_indx),
                                                        Params.GetService(),
                                                        Params.GetTransportType(), 
                                                        UTF16BE, -1, (BannerDispatcher*)&dispatch);
                            AsyncsCountGuard.Add(tmpBR);
                            Advert->requestBanner(*tmpBR);
                            
			                break;
            			}  
            	}
                Params.FreeUseAbonent(abnt_indx);
	        }	
            return 0;
        }

public:
     bool stop;
    inline void Stop() { stop = true;
                         //WaitFor();
                         pthread_cancel(thread);
                        }    
    
    // засылка параметров
    void Init(Advertising* adv, counter* cnt, int mode = SYNC_MODE_1)
    { 
        Advert  = adv;  // экземпл€р реализации Advrtise
        Counter = cnt;  // cчетчик
        runMode = mode; // режим вызова 
    }
    //------------------------------------------------------------------------------
	// обработчик результатов выполнени€     //заглушка
    void AnalizeRezult(const BannerRequest &banReq,  uint32_t rc)
	{
	    bool empty = true;
		   
	    switch (rc)
	    {
	        case 0                  :   
	                                    empty = banReq.banner.empty();
	                                    /** /
	                                    if (!empty)
	                                    {
	                                        string text;
	                                        Convertor::convert( "UTF16BE", "UTF8",
	                                                     		banReq.banner.c_str(),
	                                                     		banReq.banner.length(), text);
	                                        printf("%s\n", text.c_str());
	                                    }   
	                                    /**/
	                                break;
	                                
	        case ERR_ADV_TIMEOUT    : /*puts("getBanner was timed out"); */           break;
	        case ERR_ADV_SOCK_WRITE :/* puts("error on writing to socket");  */       break;     
	        case ERR_ADV_SOCKET     : puts("getBanner was disconnected from server"); break;
	        case ERR_ADV_PACKET_MEMBER: 
	        case ERR_ADV_PACKET_TYPE: 
	        case ERR_ADV_PACKET_LEN : printf("error on packet data: %d\n", rc);       break;
	        case ERR_ADV_QUEUE_FULL : /*puts("adverts queue overloaded");  */         break;
	        default                 : printf("getBanner error: %d\n", rc);
	    }
        if (stop) return;
        
        if (Counter)
            Counter->Increment(rc, empty);
                
        BannerRequest* banPtr = (BannerRequest*) &banReq;
        if (banPtr &&
            banPtr->dispatcher)
        {
            AsyncsCountGuard.Delete(banPtr);
            delete banPtr;                                        
        }   
    }           
    
    AdvertRun()
    {
        Counter = NULL;
        Advert  = NULL;
        dispatch.adv = this; // диспетчер у каждого потока свой - вызывает каждый свой счетчик
        
        stop=false;
    }

};

//------------------------------------------------------------------------------
// 
void kill_hand (int sig)
{
    exit(sig);
}
//------------------------------------------------------------------------------
// 
int main(int argc, char *argv[])
{
///////
    sigignore(SIGPIPE);
///////
    if(argc<5)
    {
            puts("usage: progname ip port timeout threads [mode [abonents [services]]]");
            puts("where\n\tprogname: application name");
            puts("\tip\t: IP addres of server (in digit form)");
            puts("\tport\t: server's port num");
            puts("\ttimeout\t: time of server responce waiting (in msec)");
            puts("\ttreads\t: treads amount (>=1)");
            puts("\tmode\t: syncronise mode (0...4)");
            puts("\tabonents: file with abonents list (default value: abonents.txt)");
            puts("\tservices: file with services list (default value: snames.txt)");
            puts("\nfor example: abc 192.168.1.1 1234 300 1");
            return 0;
    }
    
    struct sigaction act;
    memset(&act, 0, sizeof(act));
    act.sa_handler = kill_hand;
    act.sa_flags = SA_RESTART;
    sigaction(SIGKILL, &act, NULL);
    
    std::string host(argv[1]);
    uint32_t port=atoi(argv[2]);
    uint32_t timeout=atoi(argv[3]);
    int threads=atoi(argv[4]);
    int mode = SYNC_MODE_1;
    if (argc >= 6)
        mode = atoi(argv[5]);
    
    // инициализаци€ экземпл€ра
    // здесь максимальное количество асинхронных потоков не указываетс€!
    Advertising::Init(host,port,timeout);
    Advertising& a = Advertising::Instance();        

    // загрузка списка абонентов
    char* abonFile = "abonents.txt";
    if (argc >= 7)
        abonFile = argv[6];
    if(Params.LoadAbonentsFromTextFile(abonFile) > 0)
        printf("загрузка абонентов из файла %s", abonFile);
    else 
    {
        printf("загрузка —Ћ”„ј…Ќџ’ абонентов");
        Params.LoadDefaultAbonents(3000);        
    }            
        printf(" - загружено %d\n", Params.GetAbonentsCount());

    // загрузка списка сервисов
    char* servFile = "snames.txt";
    if (argc >= 8)     //заглушка   
        servFile = argv[7];
    
    if(Params.LoadServicesFromTextFile(servFile) > 0)
        printf("загрузка сервисов из файла %s", servFile);
    else 
    {
        printf("работа с сервисом = 10");
        Params.LoadDefaultServices(1);        
    }            
        printf(" - загружено %d\n", Params.GetServicesCount());
        
    // FIFO канал дл€ отправки данных в GUI
    int guiPipe = -1;
    if (argc >= 9)
    {
        guiPipe = open(argv[8], O_WRONLY);
        if (guiPipe < 0)
            printf("канал %s не открылс€\n", argv[7]);
    }

    // инициализаци€ счетчиков
    AdvertCount adv_count(threads, guiPipe);
    adv_count.Start();

    // инициализаци€ рабочих потоков
    AdvertRun* ar = new AdvertRun[threads];
    AdvertRun* ptr = &ar[0];
    for(int i=0; i<threads; i++, ptr++)
    {
        ptr->Init(&a, &adv_count.cnts[i], mode);
        ptr->Start();
    }

    getchar();      // срабатывает по нажатию Enter
     
    adv_count.Stop();
//    puts("closing...");
    
    if (guiPipe > 0)  close(guiPipe);

    ptr = &ar[0];
    for(int i=0; i<threads; i++, ptr++)
        ptr->Stop();

    a.Stop();
    
//    delete []ar;   
//    puts(" Ok");
   // exit(0);
    return 0;
}
