static char const ident[] = "$Id$";
#include <vector>

#include "inman/codec/asn_internal.h"
#include "inman/codec/InitialDPSMSArg.h"
#include "comps.hpp"
#include "compsutl.hpp"


namespace smsc {
namespace inman {
namespace comp {
using std::vector;


class PrivateInitialDPSMSArg
{
  public:
    PrivateInitialDPSMSArg();
    ~PrivateInitialDPSMSArg();

    InitialDPSMSArg_t idp;
};

PrivateInitialDPSMSArg::PrivateInitialDPSMSArg()
{
    memset(&idp, 0, sizeof(idp)); //clear _asn_ctx & optionals
    idp.serviceKey = 11;
}

PrivateInitialDPSMSArg::~PrivateInitialDPSMSArg()
{
/* NOTE: free content of entire structure using 'Free' method generated by asn1c */
    SEQUENCE_free(&asn_DEF_InitialDPSMSArg, &idp, 1);
}


/*
 * NOTE: The CAP4 specifies that the packed address in DestinationSubscriberNumber
 * may be up to 40 octets long, though actually, it doesn't exceed the SMS-AddressString
 * length, which is 10 octet. That's why the Address structure is used and 
 * calling the packMAPAddress2OCTS() is safe.
 */
void InitialDPSMSArg::setDestinationSubscriberNumber(const Address& addr)
{
    comp->idp.destinationSubscriberNumber = OCTET_STRING_FromAddress(addr);
}

void InitialDPSMSArg::setDestinationSubscriberNumber(const char * text)
{
    Address	sadr(text);
    InitialDPSMSArg::setDestinationSubscriberNumber((const Address&)sadr);
}

void InitialDPSMSArg::setCalledPartyNumber(const Address& addr)
{
    comp->idp.calledPartyNumber = OCTET_STRING_FromAddress(addr);
}

void InitialDPSMSArg::setCalledPartyNumber(const char * text)
{
    Address	sadr(text);
    InitialDPSMSArg::setCalledPartyNumber((const Address&)sadr);
}

void InitialDPSMSArg::setCallingPartyNumber(const Address& addr)
{
  comp->idp.callingPartyNumber = OCTET_STRING_FromAddress(addr);
}

void InitialDPSMSArg::setCallingPartyNumber(const char * text)
{
    Address	sadr(text);
    InitialDPSMSArg::setCallingPartyNumber((const Address&)sadr);
}


void InitialDPSMSArg::setIMSI(const std::string& imsi)
{
    OCTET_STRING_t *	iMSI = (OCTET_STRING_t *)CALLOC(1, sizeof(OCTET_STRING_t)); // reset _asn_ctx
    uint8_t *		str = (uint8_t *)MALLOC(imsi.length() + 1);

    strcpy((char*)(iMSI->buf = str), imsi.c_str());
    iMSI->size = (int)imsi.length();
    comp->idp.iMSI = iMSI;
}

void InitialDPSMSArg::setIMSI(const AddressValue& imsi)
{
    OCTET_STRING_t *	iMSI = (OCTET_STRING_t *)CALLOC(1, sizeof(OCTET_STRING_t)); // reset _asn_ctx
    uint8_t *		str = (uint8_t *)MALLOC(strlen(imsi) + 1);

    strcpy((char*)(iMSI->buf = str), imsi);
    iMSI->size = (int)strlen(imsi);
    comp->idp.iMSI = iMSI;
}

void InitialDPSMSArg::setSMSCAddress(const Address& addr)
{
    comp->idp.sMSCAddress = OCTET_STRING_FromAddress(addr);
}

void InitialDPSMSArg::setSMSCAddress(const char * text)
{
    Address	sadr(text);
    InitialDPSMSArg::setSMSCAddress((const Address&)sadr);
}


void InitialDPSMSArg::setTimeAndTimezone(time_t tmVal)
{
    TimeAndTimezone_t * ttz = OCTET_STRING_OBJ(CAP_MAX_TimeAndTimezoneLength);
    
    if (smsc::cvtutil::packTimeT2BCD8((unsigned char (*)[8])(ttz->buf), tmVal))
	throw runtime_error(":INMAN: bad time value");
    comp->idp.timeAndTimezone = ttz;
}

/*
void InitialDPSMSArg::setTimeAndTimezone(struct tm &tms, int &qtz)
{
    TimeAndTimezone_t * ttz = OCTET_STRING_OBJ(CAP_MAX_TimeAndTimezoneLength);

    smsc::cvtutil::packTimeSZ2BCD8((unsigned char (*)[8])(ttz->buf), tms, qtz);
    comp->idp.timeAndTimezone = ttz;
}
*/
void InitialDPSMSArg::setTPShortMessageSpecificInfo(unsigned char tPSMSI)
{
  comp->idp.tPShortMessageSpecificInfo = OCTET_STRING_OBJ(1);
  comp->idp.tPShortMessageSpecificInfo->buf[0] = tPSMSI;
}

void InitialDPSMSArg::setTPProtocolIdentifier(unsigned char tPPid)
{
  comp->idp.tPProtocolIdentifier = OCTET_STRING_OBJ(1);
  comp->idp.tPProtocolIdentifier->buf[0] = tPPid;
}

void InitialDPSMSArg::setTPDataCodingScheme(unsigned char tPDCSch)
{
  comp->idp.tPDataCodingScheme = OCTET_STRING_OBJ(1);
  comp->idp.tPDataCodingScheme->buf[0] = tPDCSch;
}

void InitialDPSMSArg::setTPValidityPeriod(time_t vpVal, enum TP_VP_format fmt)
{
    OCTET_STRING_t * octs;

    switch (fmt) {
    case tp_vp_relative:
	octs = OCTET_STRING_OBJ(1);
	octs->buf[0] = smsc::cvtutil::packTP_VP_Relative(vpVal);
	break;
    case tp_vp_absolute: {
	octs = OCTET_STRING_OBJ(7);
	if (smsc::cvtutil::packTimeT2BCD7((unsigned char (*)[7])(octs->buf), vpVal))
	    throw runtime_error(":INMAN: bad time value");
    }   break;
    default: //unsupported
	throw runtime_error(":INMAN: unsupported TP-VP format");
    }
    comp->idp.tPValidityPeriod = octs;
}

/* Sets VLR number and LocationNumber (duplicates it from VLR) */
void InitialDPSMSArg::setlocationInformationMSC(const Address& addr)
{
    comp->idp.locationInformationMSC = (LocationInformation_t *)
		CALLOC(1, sizeof(LocationInformation_t)); //reset _asn_ctx & optionals

    /* NOTE: Address cann't be the alphanumeric */
    comp->idp.locationInformationMSC->vlr_number = OCTET_STRING_FromAddress(addr);

    OCTET_STRING_t *	sptr = OCTET_STRING_OBJ(sizeof(LOCATION_ADDRESS_OCTS));
    /* pack LocationNumber  into OCTET STRING */
    sptr->size = packMAPAddress2LocationOCTS(addr, (LOCATION_ADDRESS_OCTS *)(sptr->buf));
    comp->idp.locationInformationMSC->locationNumber = sptr;
}


InitialDPSMSArg::InitialDPSMSArg(DeliveryMode_e idpMode)
{
    EventTypeSMS_t   * etSMS = (EventTypeSMS_t *)MALLOC(sizeof(EventTypeSMS_t));
    *etSMS = (EventTypeSMS_t)idpMode;

    comp = new PrivateInitialDPSMSArg();
    comp->idp.eventTypeSMS = etSMS;
}
InitialDPSMSArg::~InitialDPSMSArg() { delete(comp); }



/* this method doesn't required */
//void InitialDPSMSArg::decode(const vector<unsigned char>& buf)
//{ throw DecodeError("Not implemented"); }

void InitialDPSMSArg::encode(vector<unsigned char>& buf)
{
    asn_enc_rval_t er;
    er = der_encode(&asn_DEF_InitialDPSMSArg, &comp->idp, print2vec, &buf);

    INMAN_LOG_ENC(er, asn_DEF_InitialDPSMSArg);
}

}//namespace comp
}//namespace inman
}//namespace smsc

