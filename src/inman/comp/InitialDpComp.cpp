static char const ident[] = "$Id$";
#include <vector>
#include <time.h>

#include "inman/codec/asn_internal.h"
#include "inman/codec/InitialDPSMSArg.h"
#include "comps.hpp"
#include "compsutl.hpp"
#include "inman/common/util.hpp"
using smsc::inman::common::dump;

namespace smsc {
namespace inman {
namespace comp {
using std::vector;


class PrivateInitialDPSMSArg
{
  public:
    PrivateInitialDPSMSArg();
    ~PrivateInitialDPSMSArg();

    InitialDPSMSArg_t idp;
};

PrivateInitialDPSMSArg::PrivateInitialDPSMSArg()
{
    memset(&idp, 0, sizeof(idp)); //clear _asn_ctx & optionals
    idp.serviceKey = 11;
}

PrivateInitialDPSMSArg::~PrivateInitialDPSMSArg()
{
/* NOTE: free content of entire structure using 'Free' method generated by asn1c */
//    SEQUENCE_free(&asn_DEF_InitialDPSMSArg, &idp, 1);
}


/*
 * NOTE: The CAP4 specifies that the packed address in DestinationSubscriberNumber
 * may be up to 40 octets long, though actually, it doesn't exceed the SMS-AddressString
 * length, which is 10 octet. That's why the Address structure is used and 
 * calling the packMAPAddress2OCTS() is safe.
 */
void InitialDPSMSArg::setDestinationSubscriberNumber(const Address& addr)
{
    comp->idp.destinationSubscriberNumber = OCTET_STRING_FromAddress(addr);
}

void InitialDPSMSArg::setDestinationSubscriberNumber(const char * text)
{
    Address	sadr(text);
    InitialDPSMSArg::setDestinationSubscriberNumber((const Address&)sadr);
}

void InitialDPSMSArg::setCalledPartyNumber(const Address& addr)
{
    comp->idp.calledPartyNumber = OCTET_STRING_FromAddress(addr);
}

void InitialDPSMSArg::setCalledPartyNumber(const char * text)
{
    Address	sadr(text);
    InitialDPSMSArg::setCalledPartyNumber((const Address&)sadr);
}

void InitialDPSMSArg::setCallingPartyNumber(const Address& addr)
{
  comp->idp.callingPartyNumber = OCTET_STRING_FromAddress(addr);
}

void InitialDPSMSArg::setCallingPartyNumber(const char * text)
{
    Address	sadr(text);
    InitialDPSMSArg::setCallingPartyNumber((const Address&)sadr);
}

//imsi contains sequence of ASCII digits
void InitialDPSMSArg::setIMSI(const std::string& imsi)
{
//    OCTET_STRING_t *	iMSI = (OCTET_STRING_t *)CALLOC(1, sizeof(OCTET_STRING_t)); // reset _asn_ctx
//    uint8_t *		str = (uint8_t *)MALLOC((imsi.length() + 1)/2);

    OCTET_STRING_t *	iMSI = OCTET_STRING_OBJ((imsi.length() + 1)/2);

    iMSI->size = smsc::cvtutil::packNumString2BCD(iMSI->buf, imsi.c_str(), imsi.length());
    comp->idp.iMSI = iMSI;
}


void InitialDPSMSArg::setSMSCAddress(const Address& addr)
{
    comp->idp.sMSCAddress = OCTET_STRING_FromAddress(addr);
}

void InitialDPSMSArg::setSMSCAddress(const char * text)
{
    Address	sadr(text);
    InitialDPSMSArg::setSMSCAddress((const Address&)sadr);
}


void InitialDPSMSArg::setTimeAndTimezone(time_t tmVal)
{
	struct tm *ptime;

	assert( tmVal );

	tzset();
    ptime = localtime( &tmVal );
    assert( ptime );

    char buff[32];

    sprintf( buff, "%04d%02d%02d%02d%02d%02d00",
    		ptime->tm_year + 1900,
    		ptime->tm_mon + 1,
    		ptime->tm_mday,
    		ptime->tm_hour,
    		ptime->tm_min,
    		ptime->tm_sec );

    smsc_log_debug( logger, "GMT time: %s", buff );
    TimeAndTimezone_t * bcdTime = OCTET_STRING_OBJ(CAP_MAX_TimeAndTimezoneLength);
	int bcdLen = smsc::cvtutil::packNumString2BCD(bcdTime->buf, buff, strlen(buff));
	assert(bcdLen == CAP_MAX_TimeAndTimezoneLength);
	bcdTime->buf[bcdLen-1] = 0x42;
	smsc_log_debug( logger, "BCD time: %s", dump(bcdTime->size, bcdTime->buf).c_str() );
    comp->idp.timeAndTimezone = bcdTime;
}

/*
void InitialDPSMSArg::setTimeAndTimezone(struct tm &tms, int &qtz)
{
    TimeAndTimezone_t * ttz = OCTET_STRING_OBJ(CAP_MAX_TimeAndTimezoneLength);

    smsc::cvtutil::packTimeSZ2BCD8((unsigned char (*)[8])(ttz->buf), tms, qtz);
    comp->idp.timeAndTimezone = ttz;
}
*/
void InitialDPSMSArg::setTPShortMessageSpecificInfo(unsigned char tPSMSI)
{
  comp->idp.tPShortMessageSpecificInfo = OCTET_STRING_OBJ(1);
  comp->idp.tPShortMessageSpecificInfo->buf[0] = tPSMSI;
}

void InitialDPSMSArg::setTPProtocolIdentifier(unsigned char tPPid)
{
  comp->idp.tPProtocolIdentifier = OCTET_STRING_OBJ(1);
  comp->idp.tPProtocolIdentifier->buf[0] = tPPid;
}

void InitialDPSMSArg::setTPDataCodingScheme(unsigned char tPDCSch)
{
  comp->idp.tPDataCodingScheme = OCTET_STRING_OBJ(1);
  comp->idp.tPDataCodingScheme->buf[0] = tPDCSch;
}

void InitialDPSMSArg::setTPValidityPeriod(time_t vpVal, enum TP_VP_format fmt)
{
    OCTET_STRING_t * octs;

    switch (fmt) {
    case tp_vp_relative:
	octs = OCTET_STRING_OBJ(1);
	octs->buf[0] = smsc::cvtutil::packTP_VP_Relative(vpVal);
	break;
    case tp_vp_absolute: {
	octs = OCTET_STRING_OBJ(7);
	if (smsc::cvtutil::packTimeT2BCD7((unsigned char (*)[7])(octs->buf), vpVal))
	    throw runtime_error(":INMAN: bad time value");
    }   break;
    default: //unsupported
	throw runtime_error(":INMAN: unsupported TP-VP format");
    }
    comp->idp.tPValidityPeriod = octs;
}

/* Sets VLR number and LocationNumber (duplicates it from VLR) */
void InitialDPSMSArg::setlocationInformationMSC(const Address& addr)
{
    comp->idp.locationInformationMSC = (LocationInformation_t *)
		CALLOC(1, sizeof(LocationInformation_t)); //reset _asn_ctx & optionals

    /* NOTE: Address cann't be the alphanumeric */
    comp->idp.locationInformationMSC->vlr_number = OCTET_STRING_FromAddress(addr);

    OCTET_STRING_t *	sptr = OCTET_STRING_OBJ(sizeof(LOCATION_ADDRESS_OCTS));
    /* pack LocationNumber  into OCTET STRING */
    sptr->size = packMAPAddress2LocationOCTS(addr, (LOCATION_ADDRESS_OCTS *)(sptr->buf));
    comp->idp.locationInformationMSC->locationNumber = sptr;


	CellGlobalIdOrServiceAreaIdOrLAI_t* _cGidOrSAIorLAI1 = (CellGlobalIdOrServiceAreaIdOrLAI_t*)
		CALLOC(1, sizeof( CellGlobalIdOrServiceAreaIdOrLAI_t ) );

    _cGidOrSAIorLAI1->present =
        CellGlobalIdOrServiceAreaIdOrLAI_PR_cellGlobalIdOrServiceAreaIdFixedLength;

	static const uint8_t _cgidorsaifl1_buf[] = { 0x52, 0xf0, 0x10, 0x97, 0xFE, 0x13, 0x89 };

    _cGidOrSAIorLAI1->choice.cellGlobalIdOrServiceAreaIdFixedLength.size = 7;
    _cGidOrSAIorLAI1->choice.cellGlobalIdOrServiceAreaIdFixedLength.buf  = (unsigned char*)MALLOC( 7 );

    memcpy( _cGidOrSAIorLAI1->choice.cellGlobalIdOrServiceAreaIdFixedLength.buf,
    		_cgidorsaifl1_buf, 7 );

    comp->idp.locationInformationMSC->cellGlobalIdOrServiceAreaIdOrLAI = _cGidOrSAIorLAI1;

}


InitialDPSMSArg::InitialDPSMSArg(DeliveryMode_e idpMode)
	: logger( Logger::getInstance("smsc.inman.comp.InitialDPSMSArg") )
{
    EventTypeSMS_t   * etSMS = (EventTypeSMS_t *)MALLOC(sizeof(EventTypeSMS_t));
    *etSMS = (EventTypeSMS_t)idpMode;

    comp = new PrivateInitialDPSMSArg();
    comp->idp.eventTypeSMS = etSMS;
}
InitialDPSMSArg::~InitialDPSMSArg() { delete(comp); }



/* this method doesn't required */
//void InitialDPSMSArg::decode(const vector<unsigned char>& buf)
//{ throw DecodeError("Not implemented"); }

void InitialDPSMSArg::encode(vector<unsigned char>& buf)
{
    asn_enc_rval_t er;
    er = der_encode(&asn_DEF_InitialDPSMSArg, &comp->idp, print2vec, &buf);

    INMAN_LOG_ENC(er, asn_DEF_InitialDPSMSArg);
}

}//namespace comp
}//namespace inman
}//namespace smsc

